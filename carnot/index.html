<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>卡诺热机/热泵</title>
<style>
    .canvtext { position:absolute; display:none; color:white; background-color:rgba(0,0,0,0.5); padding:5px; z-index:10 }
    .container { position:relative; vertical-align:top; display:inline-block; margin-right:80px; border:solid 1px; padding:10px }
</style>
</head>
<body>
<h2>卡诺热机/热泵</h2>
<p>本人发明了世界第一种实用的卡诺热机/热泵。其工质气体的工作循环为真正的卡诺循环：1、等温膨胀，2、绝热膨胀，3、等温压缩，4、绝热压缩。</p>
<p>与斯特林热机/热泵相比，结构更简单，无须换热器，也无须曲轴即可输出旋转动力。工质气体与外界不以活塞分隔，能有效防止泄漏。能在所有场合替换斯特林热机。</p>
<p>与常见热机/热泵相比，热功转换效率更高，但单位体积的功率密度不如内燃机。</p>
<p>正在申请专利。需要在技术或专利方面合作者请联系：saintthor@gmail.com 。</p>

<div id="rotate" class="container">
    <div class="canvtext" style="top:10px; left:10px;"></div>
    <div class="canvtext" style="top:10px; left:280px;"></div>
    <div class="canvtext" style="top:370px; left:120px;"></div>
    <canvas width="400" height="400"></canvas>
    <div>
        <span>旋转式热机</span>&emsp;
        <button>Start</button>
        <button>Stop</button>
    </div>
    <div style="width:400px;">
        <p>气缸在立面上旋转。活塞的重力压缩下方的气体使之升温，在最低点温度最高时进入温度与高温相等的热源，开始<b>等温膨胀</b>过程。</p>
        <p>离开热源后是<b>绝热膨胀</b>过程。降温至最高点，进入温度与低温相等的冷源，开始<b>等温压缩</b>过程。</p>
        <p>离开冷源后是<b>绝热压缩</b>过程。</p>
        <p>调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合卡诺循环的定义。</p>
        <p>活塞在左侧时对气缸的旋转做功，在右侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此在连续旋转中活塞对气缸做的净功是逆时针方向的，可以维持气缸旋转并对外做功。</p>
    </div>
</div>

<div id="rotate2" class="container">
    <div class="canvtext" style="top:10px; left:10px;"></div>
    <div class="canvtext" style="top:10px; left:280px;"></div>
    <div class="canvtext" style="top:370px; left:120px;"></div>
    <canvas width="400" height="400"></canvas>
    <div>
        <span>旋转式热泵</span>&emsp;
        <button>Start</button>
        <button>Stop</button>
    </div>
    <div style="width:400px;">
        <p>气缸在立面上受外力驱动旋转。活塞的重力压缩下方的气体，转到最下方时脱离热源，开始<b>绝热膨胀</b>过程，逐渐降温。</p>
        <p>在左侧进入冷源，冷源的温度与降温后的气体相同，进入<b>等温膨胀</b>过程，从冷源吸收热量。在最高点离开冷源，开始<b>绝热压缩</b>过程，逐渐升温。</p>
        <p>在右侧进入热源，热源的温度与升温后的气体相同，开始<b>等温压缩</b>过程，向热源释放热量。</p>
        <p>调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合逆卡诺循环的定义。</p>
        <p>活塞在右侧时对气缸的旋转做功，在左侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此需要依赖外界做功才能维持运转。</p>
    </div>
</div>

<hr>
<div id="reciprocate" class="container">
    <div class="canvtext" style="top:10px; left:10px;">left</div>
    <div class="canvtext" style="top:10px; left:480px;">right</div>
    <canvas width="600" height="280"></canvas>
    <div>
        <span>往复式热机</span>&emsp;
        <button>Start</button>
        <button>Stop</button>
    </div>
    <div>
        <p>往复式的气缸能在左右方向上运动。当其内的活塞往复运动时，气缸会向相反方向运动，二者的和动量为零，振幅与二者的质量成反比。</p>
        <p>在每一边的工质气体压缩至温度最高时加上与气体温度相等的热源，同时另一边膨胀到温度最低，加上与气体温度相等的冷源，则两边分别进入等温膨胀/压缩过程。</p>
        <p>撤除热/冷源后两边分别为绝热膨胀/压缩过程，至运动到另一方向的极限位置后再反向加冷/热源，两边分别进入等温压缩/膨胀过程。</p>
        <p>撤除冷/热源后两边分别为绝热压缩/膨胀过程。在每个周期之内每一边的工质气体都经历卡诺循环的四个过程。</p>
        <p>通过气缸的运动对外做功。</p>
    </div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script>

class Carnot
{
    constructor( Id, isEngine )
    {
        let self = this;
        this.Div = document.getElementById( Id );
        this.Canvas = this.Div.querySelector( 'canvas' );
        const Bttns = this.Div.querySelectorAll( 'button' );
        Bttns[0].onclick = function() { self.Start() };
        Bttns[1].onclick = function() { self.Stop() };
        if( typeof( THREE ) === "undefined")
        {
            this.CTX = this.Canvas.getContext( '2d' );
        }
        this.Angle = 0;
        this.Interval = 40;
        this.Run = false;
        this.IsEngine = isEngine;
    }

    async Start()
    {
        if( this.Run )
        {
            return;
        }

        this.Run = true;

        let loop = async () =>
        {
            if( !this.Run )
            {
                 console.log( "Stopping animation loop." );
                 return;
            }
            this.Draw(); // Call the drawing/rendering method
            this.Angle += this.IsEngine ? 0.01 : -0.01;
            if( this.Angle < 0 )
            {
                this.Angle += Math.PI * 2;
            }
            await new Promise( r => setTimeout( r, this.Interval ) );
            loop(); // Continue loop
        };

        loop();
    }

    Draw()
    {
        return typeof( THREE ) !== "undefined" ? this.Draw3d() : this.Draw2d();
    }

    Stop()
    {
        this.Run = false;
    }
}

class ReciEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );
        // --- 3D Specific Setup ---
        if( typeof( THREE ) !== "undefined" )
        {
            this.scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight; // Use window aspect ratio
            this.camera = new THREE.PerspectiveCamera( 75, 15 / 7, 0.1, 1000 );
            this.camera.position.set( 0, 0, 25 ); // Position camera
            this.camera.aspect = 15 / 7;
            this.camera.position.z = 50;
            this.camera.fov = 20;
            this.camera.updateProjectionMatrix();

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
            this.scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );
            directionalLight.position.set( 10, 15, 20 );
            this.scene.add( directionalLight );

            this.CYLINDER_LENGTH = 20; // 无量纲，只表示比例
            this.CYLINDER_RADIUS = 2;
            this.PISTON_HEIGHT = 2;

            this.SetupObjects(); // Creates meshes and defines constants
            const [width, height] = [this.Canvas.width, this.Canvas.height];
            console.log( width, height );
            this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
            this.renderer.setSize( width, height );
        }
        else
        {
            this.Center = [Math.floor( this.Canvas.width / 2 ), Math.floor( this.Canvas.height / 2 )];
            this.LinderLength = 300;
            this.LinderWidth = 40;
            this.Interval = 24;
            this.Angle = 0;
            this.Base = { x: 150, y: 120 };
        }
        this.Draw();
    }

    SetupObjects()
    {
        // Create rotating group
        this.CyldGroup = new THREE.Group();
        this.scene.add( this.CyldGroup );

        // Create cylinder
        const cylinderGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS, this.CYLINDER_RADIUS, this.CYLINDER_LENGTH, 32, 1, true );
        const cylinderMaterial = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, transparent: true, opacity: 0.6, side: THREE.DoubleSide
        } );
        const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
        this.CyldGroup.add( cylinder );

        // Create caps
        const capGeometry = new THREE.CircleGeometry( this.CYLINDER_RADIUS, 32 );
        const capMaterial = new THREE.MeshPhongMaterial( { color: 0x666666 } );
        const topCap = new THREE.Mesh( capGeometry, capMaterial );
        topCap.position.y = this.CYLINDER_LENGTH / 2;
        topCap.rotation.x = Math.PI / 2;
        this.CyldGroup.add( topCap );
        const bottomCap = new THREE.Mesh( capGeometry, capMaterial );
        bottomCap.position.y = -this.CYLINDER_LENGTH / 2;
        bottomCap.rotation.x = -Math.PI / 2;
        this.CyldGroup.add( bottomCap );

        // Create piston
        const pistonGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS - 0.1, this.CYLINDER_RADIUS - 0.1, this.PISTON_HEIGHT, 32 );
        const pistonMaterial = new THREE.MeshPhongMaterial( { color: 0x444444 } );
        this.piston = new THREE.Mesh( pistonGeometry, pistonMaterial ); // Store piston reference
        this.CyldGroup.add( this.piston );

        this.CyldGroup.rotation.z = Math.PI / 2;

        const HotGeometry = new THREE.PlaneGeometry( 3, 1 );
        const HotMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        const ColdMaterial = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
        this.HotSrc = new THREE.Mesh( HotGeometry, HotMaterial );
        this.ColdSrc = new THREE.Mesh( HotGeometry, ColdMaterial );
        this.HotSrc.position.y = this.ColdSrc.position.y = -3;
        //this.LeftSrc.visible = false;
        this.HotSrc.position.x = -9;
        this.ColdSrc.position.x = 9;
        //hotArc.position.z = -1; // Push back slightly
        this.scene.add( this.HotSrc );
        this.scene.add( this.ColdSrc );

        this.scene.add( new THREE.AxesHelper( 12 ));
    }

    Draw3d()
    {
         if( !this.renderer || !this.scene || !this.camera )
         {
             console.log( "Renderer, scene, or camera not ready for Draw.", this.renderer, this.scene, this.camera );
             return;
         }

        if ( !this.piston ) return; // Guard clause

        //const [Sin, Cos] = [Math.sin( this.Angle ), Math.cos( this.Angle )];
        const Offset = Math.sin( this.Angle );
        this.CyldGroup.position.x = Offset * this.CYLINDER_LENGTH / 8;
        this.piston.position.y = Offset * this.CYLINDER_LENGTH / 4;

        if( this.Run )
        {
            const TextDoms = Array.from( this.Div.querySelectorAll( '.canvtext' ));
            const Quadrant = Math.floor( this.Angle / Math.PI * 2 ) % 4;
            const Stages = [['绝热压缩', '绝热膨胀'], ['等温膨胀', '等温压缩'], ['绝热膨胀', '绝热压缩'], ['等温压缩', '等温膨胀']][Quadrant];

            this.HotSrc.position.x = [50, -6, 50, 6][Quadrant];
            this.ColdSrc.position.x = [50, 9, 50, -9][Quadrant];

            TextDoms[0].innerText = '左侧：' + Stages[0];
            TextDoms[1].innerText = '右侧：' + Stages[1];
            TextDoms.forEach( t => t.style.display = 'block' );
        }

        // Render the 3D scene
        this.renderer.setClearColor( 0xebedaf );
        this.renderer.render( this.scene, this.camera );
    }

    Draw2d()
    {
        this.CTX.clearRect( 0, 0, this.Canvas.width, this.Canvas.height );

        this.CTX.beginPath();       //中线
        this.CTX.moveTo( this.Center[0], 50 );
        this.CTX.lineTo( this.Center[0], 250 );
        this.CTX.lineWidth = 2;
        this.CTX.strokeStyle = 'lightgray';
        this.CTX.stroke();

        this.CTX.strokeStyle = 'black';    //气缸
        this.CTX.lineWidth = 2;
        this.CTX.fillStyle = 'white';
        const offset = Math.sin( this.Angle ) * 40;
        this.CTX.fillRect( this.Base.x + offset + 1, this.Base.y + 1, this.LinderLength - 2, this.LinderWidth - 2 );
        this.CTX.strokeRect( this.Base.x + offset, this.Base.y, this.LinderLength, this.LinderWidth );

        this.CTX.fillStyle = 'darkgray';
        this.CTX.fillRect( this.Canvas.width / 2 - 20 - offset * 0.8, this.Base.y, 40, this.LinderWidth );

        const Angle = this.Angle % ( Math.PI * 2 );
        let stage = '绝热';
        if( Angle < Math.PI && Angle > Math.PI * 0.5 )
        {
            stage = '等温';
            this.CTX.fillStyle = 'red';
            this.CTX.fillRect( 180, this.Base.y + 45, 50, 20 );
            this.CTX.fillStyle = 'blue';
            this.CTX.fillRect( 420, this.Base.y + 45, 50, 20 );
        }
        else if( Angle < Math.PI * 2 && Angle > Math.PI * 1.5 )
        {
            stage = '等温';
            this.CTX.fillStyle = 'red';
            this.CTX.fillRect( 370, this.Base.y + 45, 50, 20 );
            this.CTX.fillStyle = 'blue';
            this.CTX.fillRect( 130, this.Base.y + 45, 50, 20 );
        }

        const Status = Number( Angle < Math.PI * 1.5 && Angle > Math.PI * 0.5 );
        this.CTX.fillStyle = 'black';
        this.CTX.font = '16px Arial';
        this.CTX.fillText( stage + ['压缩','膨胀'][Status], 180, 80 );
        this.CTX.fillText( stage + ['膨胀','压缩'][Status], 360, 80 );
    }
}

class RotEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );

        // --- 3D Specific Setup ---
        if( typeof( THREE ) !== "undefined" )
        {
            this.scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight; // Use window aspect ratio
            this.camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            this.camera.position.set( 0, 0, 25 ); // Position camera
            this.camera.aspect = 1;
            this.camera.updateProjectionMatrix();

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
            this.scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );
            directionalLight.position.set( 10, 15, 20 );
            this.scene.add( directionalLight );

            this.CYLINDER_LENGTH = 24; // 无量纲，只表示比例
            this.CYLINDER_RADIUS = 2;
            this.PISTON_HEIGHT = 2;

            this.SetupObjects(); // Creates meshes and defines constants
            const [width, height] = [this.Canvas.innerWidth, this.Canvas.innerHeight];
            this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
            this.renderer.setSize( 400, 400 );
        }
        else
        {
            this.Center = [Math.floor( this.Canvas.width / 2 ), Math.floor( this.Canvas.height / 2 )];
            this.LinderLength = 280;
            this.LinderWidth = 30;
            this.Radius = 150;
        }
        this.Draw();
    }

    SetupObjects()
    {
        // Create rotating group
        this.rotatingGroup = new THREE.Group();
        this.scene.add( this.rotatingGroup );

        // Create cylinder
        const cylinderGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS, this.CYLINDER_RADIUS, this.CYLINDER_LENGTH, 32, 1, true );
        const cylinderMaterial = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, transparent: true, opacity: 0.6, side: THREE.DoubleSide
        } );
        const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
        this.rotatingGroup.add( cylinder );

        // Create caps
        const capGeometry = new THREE.CircleGeometry( this.CYLINDER_RADIUS, 32 );
        const capMaterial = new THREE.MeshPhongMaterial( { color: 0x666666 } );
        const topCap = new THREE.Mesh( capGeometry, capMaterial );
        topCap.position.y = this.CYLINDER_LENGTH / 2;
        topCap.rotation.x = Math.PI / 2;
        this.rotatingGroup.add( topCap );
        const bottomCap = new THREE.Mesh( capGeometry, capMaterial );
        bottomCap.position.y = -this.CYLINDER_LENGTH / 2;
        bottomCap.rotation.x = -Math.PI / 2;
        this.rotatingGroup.add( bottomCap );

        // Create piston
        const pistonGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS - 0.1, this.CYLINDER_RADIUS - 0.1, this.PISTON_HEIGHT, 32 );
        const pistonMaterial = new THREE.MeshPhongMaterial( { color: 0x444444 } );
        this.piston = new THREE.Mesh( pistonGeometry, pistonMaterial ); // Store piston reference
        this.rotatingGroup.add( this.piston );

        // Heat Source / Cold Source Indicators ( Arcs )
        const arcRadius = this.CYLINDER_LENGTH * 0.6; // Adjust radius as needed
        const hotArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, 3 * Math.PI / 2, 2 * Math.PI, false ).getPoints( 50 )
        );
        const hotArcMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 3 } );
        const hotArc = new THREE.Line( hotArcGeometry, hotArcMaterial );
        hotArc.position.z = -1; // Push back slightly
        this.scene.add( hotArc );

        const coldArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, Math.PI / 2, Math.PI, false ).getPoints( 50 )
        );
        const coldArcMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff, linewidth: 3 } );
        const coldArc = new THREE.Line( coldArcGeometry, coldArcMaterial );
        coldArc.position.z = -1; // Push back slightly
        this.scene.add( coldArc );

        this.scene.add( new THREE.AxesHelper( 12 ));
    }

    Draw3d()
    {
         if( !this.renderer || !this.scene || !this.camera )
         {
             console.log( "Renderer, scene, or camera not ready for Draw.", this.renderer, this.scene, this.camera );
             return;
         }

        // Update objects based on state ( this.Angle )
        if( this.rotatingGroup )
        {
            this.rotatingGroup.rotation.z = this.Angle;
        }

        if ( !this.piston ) return; // Guard clause

        const [Sin, Cos] = [Math.sin( this.Angle ), Math.cos( this.Angle )];
        const Offset = -Cos * ( Sin * Cos > 0 ? 1.2 : 0.8 ) + ( Sin > 0 ? 0.2 : -0.2 );
        this.piston.position.y = Offset * this.CYLINDER_LENGTH / 4;

        if( this.Run )
        {
            const TextDoms = Array.from( this.Div.querySelectorAll( '.canvtext' ));
            const stage = Sin * Cos > 0 ? '等温' : '绝热';

            TextDoms[0].innerText = '左侧：' + stage + ( this.IsEngine ? '压缩' : '膨胀' );
            TextDoms[1].innerText = '右侧：' + stage + ( this.IsEngine ? '膨胀' : '压缩' );

            if( Offset * Sin > 0 )
            {
                TextDoms[2].innerText = ['气缸对活塞做功', '活塞对气缸做功'][this.IsEngine];
                TextDoms[2].style.left = '80px';
            }
            else
            {
                TextDoms[2].innerText = ['活塞对气缸做功', '气缸对活塞做功'][this.IsEngine];
                TextDoms[2].style.left = '210px';
            }

            TextDoms.forEach( t => t.style.display = 'block' );
        }

        // Render the 3D scene
        this.renderer.setClearColor( 0xebedaf );
        this.renderer.render( this.scene, this.camera );
    }

    Draw2d()
    {
        this.CTX.clearRect( 0, 0, this.Canvas.width, this.Canvas.height );

        this.CTX.beginPath();       //中线
        this.CTX.moveTo( this.Center[0], 50 );
        this.CTX.lineTo( this.Center[0], 350 );
        this.CTX.lineWidth = 2;
        this.CTX.strokeStyle = 'lightgray';
        this.CTX.stroke();

        this.CTX.lineWidth = 10;
        this.CTX.beginPath();       //热源
        this.CTX.arc( this.Center[0], this.Center[1], this.Radius, 0, Math.PI / 2, false );
        this.CTX.strokeStyle = 'red';
        this.CTX.stroke();

        this.CTX.beginPath();       //冷源
        this.CTX.arc( this.Center[0], this.Center[1], this.Radius, Math.PI, -Math.PI / 2, false );
        this.CTX.strokeStyle = 'blue';
        this.CTX.stroke();

        this.CTX.save();    //绘制旋转的气缸
        this.CTX.translate( ...this.Center );
        this.CTX.rotate( -this.Angle ); //逆时针旋转
        this.CTX.strokeStyle = 'black';    //绘制无填充色的矩形，仅有黑色边框
        this.CTX.lineWidth = 2;
        this.CTX.strokeRect( -this.LinderWidth / 2, -this.LinderLength / 2, this.LinderWidth, this.LinderLength );

        let Offset, stage;    // 计算活塞位置
        const Angle = this.Angle % ( Math.PI * 2 );
        if( Angle % Math.PI <= Math.PI / 2 )
        {    // 从最下方 0 ~ pi/2
            Offset = Math.cos( Angle ) * this.LinderLength / 3 - 26 * [1, -1][Number( Angle >= Math.PI )];
            stage = '等温';
        }
        else
        {   // pi/2 ~ pi
            Offset = Math.cos( Angle ) * ( this.LinderLength - 156 ) / 3 - 26 * [1, -1][Number( Angle >= Math.PI )];
            stage = '绝热';
        }
        this.CTX.fillStyle = 'darkgray';
        this.CTX.fillRect( -this.LinderWidth/2, Offset - 10, this.LinderWidth, 20 );
        this.CTX.restore();

        // 标记卡诺循环阶段
        this.CTX.fillStyle = 'black';
        this.CTX.font = '16px Arial';
        const Index = Number( this.IsEngine );
        this.CTX.fillText( `${ stage }压缩`, [300, 20][Index], 40 );
        this.CTX.fillText( `${ stage }膨胀`, [20, 300][Index], 40 );
        this.CTX.fillText( [['气缸对活塞做功', '      活塞对气缸做功'], ['活塞对气缸做功', '      气缸对活塞做功']][Index][Number( Offset * ( Angle - Math.PI ) < 0 && Angle % Math.PI <= Math.PI / 2 )], 130, 380 );
    }
}

new RotEngine( 'rotate', 1 );
new RotEngine( 'rotate2', 0 );
new ReciEngine( 'reciprocate', 1 );
</script>
</body>
</html>
