<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>卡诺热机/热泵</title>
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+SC:wght@400;700&display=swap" rel="stylesheet">
<style>
    .canvtext { position:absolute; display:none; color:white; background-color:rgba(0,0,0,0.5); padding:5px; z-index:10 }
    .container { position:relative; vertical-align:top; display:inline-block; margin-right:80px; border:solid 1px; padding:10px }
    .inline-svg { display: inline-block; vertical-align: middle;
            width: 1em;   /* 确保大小与文字相近 */
            height: 1em;  /* 确保大小与文字相近 */
            transform: translateY(0.1em);
        }

    body {
        font-family: "Noto Sans SC", -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
        line-height: 1.6;
        margin: 0 auto;
        max-width: 1200px;
        padding: 20px;
        background-color: #f9f9f9;
        color: #333;
    }
    h1, h2, h3 {
        color: #2c3e50;
    }
    .tabs-container {
        margin-top: 20px;
        background: #fff;
        border-radius: 8px;
        box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        overflow: hidden;
    }
    .tabs-nav {
        display: flex;
        flex-wrap: wrap;
        background-color: #ecf0f1;
        border-bottom: 2px solid #bdc3c7;
    }
    .tab-button {
        padding: 12px 18px;
        cursor: pointer;
        border: none;
        background-color: transparent;
        font-size: 16px;
        color: #7f8c8d;
        transition: all 0.3s ease;
        border-bottom: 3px solid transparent;
    }
    .tab-button:hover {
        background-color: #fff;
        color: #3498db;
    }
    .tab-button.active {
        background-color: #fff;
        color: #2980b9;
        border-bottom-color: #3498db;
        font-weight: bold;
    }
    .tabs-content {
        padding: 25px;
    }
    .tab-pane {
        display: none;
    }
    .tab-pane.active {
        display: block;
        animation: fadeIn 0.5s;
    }
    @keyframes fadeIn {
        from { opacity: 0; }
        to { opacity: 1; }
    }
    .container {
        border: 1px solid #ddd;
        border-radius: 5px;
    }
    .animation-layout {
        display: flex;
        flex-wrap: wrap;
        gap: 25px;
    }
    .animation-visual {
        flex-shrink: 0;
        position: relative;
    }
    .animation-description {
        flex: 1;
        min-width: 300px;
    }
    #lang-toggle {
        margin-left: 15px;
        padding: 5px 10px;
        cursor: pointer;
        border: 1px solid #ccc;
        border-radius: 5px;
        background-color: #f0f0f0;
        font-family: inherit;
    }
</style>
</head>
<body>
<h1><span data-lang-key="title">卡诺热机/热泵</span><button id="lang-toggle">English</button></h1>
<p data-lang-key="intro1">本人发明了世界首创的卡诺热机/热泵。其工质气体的工作循环为真正的卡诺循环：1、等温膨胀，2、绝热膨胀，3、等温压缩，4、绝热压缩。</p>
<p data-lang-key="intro2">具有热功转换效率高、结构简单、易于维护、灵活自启动、适用于多种热源/冷源、无须曲轴即可输出旋转动力等优势。工质气体与外界不以活塞分隔，能有效防止泄漏。能在所有场合替换斯特林热机/热泵，并可在发电、工业动力与大型交通工具上替代其它热机。</p>
<p data-lang-key="intro3">正在申请专利。需要在技术或专利方面合作者请联系：saintthor@gmail.com 。</p>

<div class="tabs-container">
    <div class="tabs-nav">
        <button class="tab-button active" data-target="panel-rotate" data-lang-key="tab_rotate_engine">旋转式热机</button>
        <button class="tab-button" data-target="panel-rotate2" data-lang-key="tab_rotate_pump">旋转式热泵</button>
        <button class="tab-button" data-target="panel-reciprocate" data-lang-key="tab_reciprocate_engine">往复式热机</button>
        <button class="tab-button" data-target="panel-ring" data-lang-key="tab_ring_engine">环管动能式热机</button>
        <button class="tab-button" data-target="panel-ring2" data-lang-key="tab_empty_engine">空管式热机</button>
        <button class="tab-button" data-target="panel-switch" data-lang-key="tab_switch">导热切换</button>
        <button class="tab-button" data-target="panel-video1" data-lang-key="tab_video1">叉管旋转式模型</button>
        <button class="tab-button" data-target="panel-video2" data-lang-key="tab_video2">满管旋转式模型</button>
        <button class="tab-button" data-target="panel-video3" data-lang-key="tab_video3">环管动能式模型</button>
    </div>

    <div class="tabs-content">
        <div id="panel-rotate" class="tab-pane active">
            <h2 data-lang-key="principle">原理</h2>
            <div id="rotate" class="container">
                <div class="animation-layout">
                    <div class="animation-visual">
                        <div class="canvtext" style="top:10px; left:10px;"></div>
                        <div class="canvtext" style="top:10px; left:270px;"></div>
                        <div class="canvtext" style="top:370px; left:120px;"></div>
                        <canvas width="400" height="400"></canvas>
                        <div>
                            <span data-lang-key="rotate_engine">旋转式热机</span>&emsp;
                            <button>Start</button>
                        </div>
                    </div>
                    <div class="animation-description">
                        <p data-lang-key="rotate_p1">气缸在立面上旋转。活塞的重力压缩下方的气体使之升温，在最低点温度最高时进入温度与高温相等的热源，开始<b>等温膨胀</b>过程。</p>
                        <p data-lang-key="rotate_p2">离开热源后是<b>绝热膨胀</b>过程。降温至最高点，进入温度与低温相等的冷源，开始<b>等温压缩</b>过程。</p>
                        <p data-lang-key="rotate_p3">离开冷源后是<b>绝热压缩</b>过程。</p>
                        <p data-lang-key="rotate_p4">调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合卡诺循环的定义。</p>
                        <p data-lang-key="rotate_p5">活塞在左侧时对气缸的旋转做功，在右侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此在连续旋转中活塞对气缸做的净功是逆时针方向的，可以维持气缸旋转并对外做功。</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-rotate2" class="tab-pane">
            <div id="rotate2" class="container">
                <div class="animation-layout">
                    <div class="animation-visual">
                        <div class="canvtext" style="top:10px; left:10px;"></div>
                        <div class="canvtext" style="top:10px; left:270px;"></div>
                        <div class="canvtext" style="top:370px; left:120px;"></div>
                        <canvas width="400" height="400"></canvas>
                        <div>
                            <span data-lang-key="rotate_pump">旋转式热泵</span>&emsp;
                            <button>Start</button>
                        </div>
                    </div>
                    <div class="animation-description">
                        <p data-lang-key="rotate2_p1">气缸在立面上受外力驱动旋转。活塞的重力压缩下方的气体，转到最下方时脱离热源，开始<b>绝热膨胀</b>过程，逐渐降温。</p>
                        <p data-lang-key="rotate2_p2">在左侧进入冷源，冷源的温度与降温后的气体相同，进入<b>等温膨胀</b>过程，从冷源吸收热量。在最高点离开冷源，开始<b>绝热压缩</b>过程，逐渐升温。</p>
                        <p data-lang-key="rotate2_p3">在右侧进入热源，热源的温度与升温后的气体相同，开始<b>等温压缩</b>过程，向热源释放热量。</p>
                        <p data-lang-key="rotate2_p4">调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合逆卡诺循环的定义。</p>
                        <p data-lang-key="rotate2_p5">活塞在右侧时对气缸的旋转做功，在左侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此需要依赖外界做功才能维持运转。</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-reciprocate" class="tab-pane">
            <div id="reciprocate" class="container">
                <div class="canvtext" style="top:10px; left:10px;">left</div>
                <div class="canvtext" style="top:10px; left:480px;">right</div>
                <canvas width="600" height="280"></canvas>
                <div>
                    <span data-lang-key="reciprocate_engine">往复式热机</span>&emsp;
                    <button>Start</button>
                </div>
                <div>
                    <p data-lang-key="reciprocate_p1">往复式的气缸能在左右方向上运动。当其内的活塞往复运动时，气缸会向相反方向运动，二者的和动量为零，振幅与二者的质量成反比。</p>
                    <p data-lang-key="reciprocate_p2">在每一边的工质气体压缩至温度最高时加上与气体温度相等的热源，同时另一边膨胀到温度最低，加上与气体温度相等的冷源，则两边分别进入等温膨胀/压缩过程。</p>
                    <p data-lang-key="reciprocate_p3">撤除热/冷源后两边分别为绝热膨胀/压缩过程，至运动到另一方向的极限位置后再反向加冷/热源，两边分别进入等温压缩/膨胀过程。</p>
                    <p data-lang-key="reciprocate_p4">撤除冷/热源后两边分别为绝热压缩/膨胀过程。在每个周期之内每一边的工质气体都经历卡诺循环的四个过程。</p>
                    <p data-lang-key="reciprocate_p5">通过气缸的运动对外做功。</p>
                </div>
            </div>
        </div>

        <div id="panel-ring" class="tab-pane">
            <div id="ring" class="container">
                <div class="animation-layout">
                    <div class="animation-visual">
                        <div class="canvtext" style="top:10px; left:10px;"></div>
                        <div class="canvtext" style="top:10px; left:270px;"></div>
                        <canvas width="400" height="400"></canvas>
                        <div>
                            <span data-lang-key="ring_engine">环管动能式热机</span>&emsp;
                            <button>Start</button>
                        </div>
                    </div>
                    <div class="animation-description">
                        <p data-lang-key="ring_p1">气缸为环形管，上有两个阀门，总是一开一闭。两根直管两端也各有一个阀门。所有阀门绿色为导通，红色为截止。直管上的阀门状态总是与较近的环管阀门相反。</p>
                        <p data-lang-key="ring_p2">任一时刻，气缸通路总是由一根直管的红色阀门开始，经过三个绿色阀门，转一圈后，到达另一根直管的红色阀门，形状如同<span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g>
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>。</p>
                        <p data-lang-key="ring_p3">环形管每旋转半圈，阀门切换一次，所有阀门一齐翻转。每次切换前的管形如<span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g transform="scale(-1, 1)">
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>，开口向左，切换后又变成<span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g>
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>。</p>
                        <p data-lang-key="ring_p4">环管下方有一段高密度的液柱。由于环管可旋转且较轻，无负载时液柱总是保持在正下方。液柱两侧气压不同时会驱动环形管转动。</p>
                        <p data-lang-key="ring_p5">每次阀门切换之后，对下方的直管加热源，对上方的直管加冷源，则液柱右侧热直管一端的气体为等温膨胀，液柱左侧冷直管一端的气体为等温压缩。</p>
                        <p data-lang-key="ring_p6">撤除热源与冷源后，环管因惯性继续旋转，液柱右侧的气体为绝热膨胀，液柱左侧的气体为绝热压缩。对惯性的利用方式与往复式热机相似。</p>
                        <p data-lang-key="ring_p7">绿色的环管阀门离开液柱区域之后，阀门切换，原压缩端变成膨胀端，原膨胀端变成压缩端，开始下一个循环。</p>
                        <p data-lang-key="ring_p8">通过气缸的旋转对外做功。</p>
                        <p data-lang-key="ring_p9">这种热机能灵活适配可变的负载。负载越大，液柱的位置越向左偏。</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-ring2" class="tab-pane">
            <div id="ring2" class="container">
                <div class="animation-layout">
                    <div class="animation-visual">
                        <div style="position:absolute; padding:5px; z-index:10; top:10px; left:10px;" data-lang-key="isothermal_compression">等温压缩</div>
                        <div style="position:absolute; padding:5px; z-index:10; top:10px; left:320px;" data-lang-key="adiabatic_expansion">绝热膨胀</div>
                        <div style="position:absolute; padding:5px; z-index:10; top:370px; left:10px;" data-lang-key="adiabatic_compression">绝热压缩</div>
                        <div style="position:absolute; padding:5px; z-index:10; top:370px; left:320px;" data-lang-key="isothermal_expansion">等温膨胀</div>
                        <canvas width="400" height="400"></canvas>
                        <div>
                            <span data-lang-key="empty_engine">空管式热机</span>&emsp;
                            <button>Start</button>
                        </div>
                    </div>
                    <div class="animation-description">
                        <p data-lang-key="empty_p1">环形管里没有活塞，充满高压高密度工质气体，靠气体自重产生压强，令下方气体温度升高。</p>
                        <p data-lang-key="empty_p2">环形管内有十二个阀门。每个阀门在七点钟位置到六点钟位置之间封闭，其余位置开启。任一时刻至少有一个阀门是封闭的。</p>
                        <p data-lang-key="empty_p3">每次六点钟位置的阀门开启时，六点钟到七点钟区段的气体开始接触热源，热源与气体温度相等。此后这部分气体向上运动，压强减小而膨胀，同时从热源吸热，处于等温膨胀过程。</p>
                        <p data-lang-key="empty_p4">离开热源后继续上行并膨胀，处于绝热膨胀过程，降温。</p>
                        <p data-lang-key="empty_p5">在最上方接触与自身温度相等的冷源，此后向下运动，压强增大而压缩，向冷源放热，处于等温压缩过程。</p>
                        <p data-lang-key="empty_p6">离开冷源后继续下行并压缩，处于绝热压缩过程，升温。构成卡诺循环。</p>
                        <p data-lang-key="empty_p7">左半边温度低，故封闭的阀门左侧压强总是较大，推动环形管向逆时针方向旋转并对外做功。也可以不设阀门，改为在环形管内加涡轮发电。</p>
                        <p data-lang-key="empty_p8">由于气体的密度难以达到液体和固体的水平，只在尺寸大、温差小的条件下能依上述卡诺循环方式运行。不满足条件时以布雷顿循环运行。</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-switch" class="tab-pane">
            <div id="switch" class="container">
                <div class="animation-layout">
                    <div class="animation-visual">
                        <div class="canvtext" style="top:570px; left:210px;">left</div>
                        <canvas width="600" height="600"></canvas>
                        <div>
                            <span data-lang-key="switch">导热切换</span>&emsp;
                            <button>Start</button>
                        </div>
                    </div>
                    <div class="animation-description">
                        <p data-lang-key="switch_p1">前面的各种卡诺热机都面临导热切换的问题。气缸时而导热，时而绝热，由于现实固体材料的比热容太大，导热切换会造成明显的损耗。</p>
                        <p data-lang-key="switch_p2">这是一个高效的切换方案。气缸两侧各有一个固定腔。左侧为热腔，保持在高温；右侧为冷腔，保持在低温。</p>
                        <p data-lang-key="switch_p3">气缸与两腔之间各有两条通道。前面两条通道上各有阀门。后面两条通道内各有一个活塞，用于保证三个腔的压强总是相等。</p>
                        <p data-lang-key="switch_p4">当两个阀门都关闭时，气缸内气体处于绝热过程。当左阀门开启，气缸与热腔相连，处于等温膨胀；当右阀门开启，气缸与冷腔相连，处于等温压缩。</p>
                        <p data-lang-key="switch_p5">飞轮有助于理解活塞的周期性运动。现实的热机如果这样做，活塞的气密性可能挑战较大。推荐的用法是作为旋转式或往复式气缸的一端，也可用于环管式。</p>
                    </div>
                </div>
            </div>
        </div>

        <div id="panel-video1" class="tab-pane">
            <h2 data-lang-key="physical_models">实物模型</h2>
            <div data-lang-key="model_intro">这些模型都是用水作活塞，气密性高，阻力小。适用于低温差（5度左右）的场景。若要适配于高温差的工业场景，应增大转盘尺寸，及换用高密度液体，才能近似卡诺循环。</div>
            <div>
                <h3 data-lang-key="video1_title">叉管旋转式卡诺热机</h3>
                <iframe data-src="https://embed.wave.video/tk7QOjRSttH0TcbS" height="420" width="560" frameborder="0" allow="autoplay; fullscreen" scrolling="no"></iframe>
            </div>
        </div>

        <div id="panel-video2" class="tab-pane">
            <h3 data-lang-key="video2_title">低温差满管旋转式卡诺热机</h3>
            <iframe data-src="https://embed.wave.video/iJUNKnerXzky7jQw" height="420" width="560" frameborder="0" allow="autoplay; fullscreen" scrolling="no"></iframe>
        </div>

        <div id="panel-video3" class="tab-pane">
            <h3 data-lang-key="video3_title">环管动能式卡诺热机</h3>
            <iframe data-src="https://embed.wave.video/RUomyep3SdOl9Xuk" height="420" width="560" frameborder="0" allow="autoplay; fullscreen" scrolling="no"></iframe>
        </div>
    </div>
</div>

<script type="text/javascript" src="https://counter4.optistats.ovh/private/counter.js?c=kwt9a3nklac41tmaqer9sbwzzeqshq7y&down=async" async></script>
<noscript><a href="https://www.freecounterstat.com" title="web counter"><img src="https://counter4.optistats.ovh/private/freecounterstat.php?c=kwt9a3nklac41tmaqer9sbwzzeqshq7y" border="0" title="web counter" alt="web counter"></a></noscript>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>

<script>
const translations = {
    zh: {
        title: "卡诺热机/热泵",
        intro1: "本人发明了世界首创的卡诺热机/热泵。其工质气体的工作循环为真正的卡诺循环：1、等温膨胀，2、绝热膨胀，3、等温压缩，4、绝热压缩。",
        intro2: "具有热功转换效率高、结构简单、易于维护、灵活自启动、适用于多种热源/冷源、无须曲轴即可输出旋转动力等优势。工质气体与外界不以活塞分隔，能有效防止泄漏。能在所有场合替换斯特林热机/热泵，并可在发电、工业动力与大型交通工具上替代其它热机。",
        intro3: "正在申请专利。需要在技术或专利方面合作者请联系：saintthor@gmail.com 。",
        tab_rotate_engine: "旋转式热机",
        tab_rotate_pump: "旋转式热泵",
        tab_reciprocate_engine: "往复式热机",
        tab_ring_engine: "环管动能式热机",
        tab_empty_engine: "空管式热机",
        tab_switch: "导热切换",
        tab_video1: "叉管旋转式模型",
        tab_video2: "满管旋转式模型",
        tab_video3: "环管动能式模型",
        principle: "原理",
        rotate_engine: "旋转式热机",
        rotate_p1: "气缸在立面上旋转。活塞的重力压缩下方的气体使之升温，在最低点温度最高时进入温度与高温相等的热源，开始<b>等温膨胀</b>过程。",
        rotate_p2: "离开热源后是<b>绝热膨胀</b>过程。降温至最高点，进入温度与低温相等的冷源，开始<b>等温压缩</b>过程。",
        rotate_p3: "离开冷源后是<b>绝热压缩</b>过程。",
        rotate_p4: "调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合卡诺循环的定义。",
        rotate_p5: "活塞在左侧时对气缸的旋转做功，在右侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此在连续旋转中活塞对气缸做的净功是逆时针方向的，可以维持气缸旋转并对外做功。",
        rotate_pump: "旋转式热泵",
        rotate2_p1: "气缸在立面上受外力驱动旋转。活塞的重力压缩下方的气体，转到最下方时脱离热源，开始<b>绝热膨胀</b>过程，逐渐降温。",
        rotate2_p2: "在左侧进入冷源，冷源的温度与降温后的气体相同，进入<b>等温膨胀</b>过程，从冷源吸收热量。在最高点离开冷源，开始<b>绝热压缩</b>过程，逐渐升温。",
        rotate2_p3: "在右侧进入热源，热源的温度与升温后的气体相同，开始<b>等温压缩</b>过程，向热源释放热量。",
        rotate2_p4: "调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合逆卡诺循环的定义。",
        rotate2_p5: "活塞在右侧时对气缸的旋转做功，在左侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此需要依赖外界做功才能维持运转。",
        reciprocate_engine: "往复式热机",
        reciprocate_p1: "往复式的气缸能在左右方向上运动。当其内的活塞往复运动时，气缸会向相反方向运动，二者的和动量为零，振幅与二者的质量成反比。",
        reciprocate_p2: "在每一边的工质气体压缩至温度最高时加上与气体温度相等的热源，同时另一边膨胀到温度最低，加上与气体温度相等的冷源，则两边分别进入等温膨胀/压缩过程。",
        reciprocate_p3: "撤除热/冷源后两边分别为绝热膨胀/压缩过程，至运动到另一方向的极限位置后再反向加冷/热源，两边分别进入等温压缩/膨胀过程。",
        reciprocate_p4: "撤除冷/热源后两边分别为绝热压缩/膨胀过程。在每个周期之内每一边的工质气体都经历卡诺循环的四个过程。",
        reciprocate_p5: "通过气缸的运动对外做功。",
        ring_engine: "环管动能式热机",
        ring_p1: "气缸为环形管，上有两个阀门，总是一开一闭。两根直管两端也各有一个阀门。所有阀门绿色为导通，红色为截止。直管上的阀门状态总是与较近的环管阀门相反。",
        ring_p2: `任一时刻，气缸通路总是由一根直管的红色阀门开始，经过三个绿色阀门，转一圈后，到达另一根直管的红色阀门，形状如同<span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g>
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>。`,
        ring_p3: `环形管每旋转半圈，阀门切换一次，所有阀门一齐翻转。每次切换前的管形如<span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g transform="scale(-1, 1)">
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>，开口向左，切换后又变成<span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g>
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>。`,
        ring_p4: "环管下方有一段高密度的液柱。由于环管可旋转且较轻，无负载时液柱总是保持在正下方。液柱两侧气压不同时会驱动环形管转动。",
        ring_p5: "每次阀门切换之后，对下方的直管加热源，对上方的直管加冷源，则液柱右侧热直管一端的气体为等温膨胀，液柱左侧冷直管一端的气体为等温压缩。",
        ring_p6: "撤除热源与冷源后，环管因惯性继续旋转，液柱右侧的气体为绝热膨胀，液柱左侧的气体为绝热压缩。对惯性的利用方式与往复式热机相似。",
        ring_p7: "绿色的环管阀门离开液柱区域之后，阀门切换，原压缩端变成膨胀端，原膨胀端变成压缩端，开始下一个循环。",
        ring_p8: "通过气缸的旋转对外做功。",
        ring_p9: "这种热机能灵活适配可变的负载。负载越大，液柱的位置越向左偏。",
        empty_engine: "空管式热机",
        isothermal_compression: "等温压缩",
        adiabatic_expansion: "绝热膨胀",
        adiabatic_compression: "绝热压缩",
        isothermal_expansion: "等温膨胀",
        empty_p1: "环形管里没有活塞，充满高压高密度工质气体，靠气体自重产生压强，令下方气体温度升高。",
        empty_p2: "环形管内有十二个阀门。每个阀门在七点钟位置到六点钟位置之间封闭，其余位置开启。任一时刻至少有一个阀门是封闭的。",
        empty_p3: "每次六点钟位置的阀门开启时，六点钟到七点钟区段的气体开始接触热源，热源与气体温度相等。此后这部分气体向上运动，压强减小而膨胀，同时从热源吸热，处于等温膨胀过程。",
        empty_p4: "离开热源后继续上行并膨胀，处于绝热膨胀过程，降温。",
        empty_p5: "在最上方接触与自身温度相等的冷源，此后向下运动，压强增大而压缩，向冷源放热，处于等温压缩过程。",
        empty_p6: "离开冷源后继续下行并压缩，处于绝热压缩过程，升温。构成卡诺循环。",
        empty_p7: "左半边温度低，故封闭的阀门左侧压强总是较大，推动环形管向逆时针方向旋转并对外做功。也可以不设阀门，改为在环形管内加涡轮发电。",
        empty_p8: "由于气体的密度难以达到液体和固体的水平，只在尺寸大、温差小的条件下能依上述卡诺循环方式运行。不满足条件时以布雷顿循环运行。",
        "switch": "导热切换",
        switch_p1: "前面的各种卡诺热机都面临导热切换的问题。气缸时而导热，时而绝热，由于现实固体材料的比热容太大，导热切换会造成明显的损耗。",
        switch_p2: "这是一个高效的切换方案。气缸两侧各有一个固定腔。左侧为热腔，保持在高温；右侧为冷腔，保持在低温。",
        switch_p3: "气缸与两腔之间各有两条通道。前面两条通道上各有阀门。后面两条通道内各有一个活塞，用于保证三个腔的压强总是相等。",
        switch_p4: "当两个阀门都关闭时，气缸内气体处于绝热过程。当左阀门开启，气缸与热腔相连，处于等温膨胀；当右阀门开启，气缸与冷腔相连，处于等温压缩。",
        switch_p5: "飞轮有助于理解活塞的周期性运动。现实的热机如果这样做，活塞的气密性可能挑战较大。推荐的用法是作为旋转式或往复式气缸的一端，也可用于环管式。",
        physical_models: "实物模型",
        model_intro: "这些模型都是用水作活塞，气密性高，阻力小。适用于低温差（5度左右）的场景。若要适配于高温差的工业场景，应增大转盘尺寸，及换用高密度液体，才能近似卡诺循环。",
        video1_title: "叉管旋转式卡诺热机",
        video2_title: "低温差满管旋转式卡诺热机",
        video3_title: "环管动能式卡诺热机",
    },
    en: {
        title: "Carnot Engine/Heat Pump",
        intro1: "I have invented the world's first Carnot engine/heat pump. Its working gas cycle is a true Carnot cycle: 1. Isothermal expansion, 2. Adiabatic expansion, 3. Isothermal compression, 4. Adiabatic compression.",
        intro2: "It has advantages such as high heat-to-work conversion efficiency, simple structure, easy maintenance, flexible self-starting, suitability for various heat/cold sources, and the ability to output rotational power without a crankshaft. The working gas is not separated from the outside by a piston, effectively preventing leakage. It can replace Stirling engines/heat pumps in all applications and can replace other heat engines in power generation, industrial power, and large transportation vehicles.",
        intro3: "Patent pending. Those interested in technical or patent cooperation, please contact: saintthor@gmail.com.",
        tab_rotate_engine: "Rotary Engine",
        tab_rotate_pump: "Rotary Heat Pump",
        tab_reciprocate_engine: "Reciprocating Engine",
        tab_ring_engine: "Ring-Kinetic Engine",
        tab_empty_engine: "Empty-Tube Engine",
        tab_switch: "Thermal Switch",
        tab_video1: "Fork-Tube Rotary Model",
        tab_video2: "Full-Tube Rotary Model",
        tab_video3: "Ring-Kinetic Model",
        principle: "Principle",
        rotate_engine: "Rotary Heat Engine",
        rotate_p1: "The cylinder rotates on a vertical plane. The gravity of the piston compresses the gas below, raising its temperature. At the lowest point, when the temperature is highest, it enters a heat source of the same high temperature, beginning the <b>isothermal expansion</b> process.",
        rotate_p2: "After leaving the heat source, it undergoes an <b>adiabatic expansion</b> process. The temperature drops to its lowest at the highest point, where it enters a cold source of the same low temperature, beginning the <b>isothermal compression</b> process.",
        rotate_p3: "After leaving the cold source, it undergoes an <b>adiabatic compression</b> process.",
        rotate_p4: "By adjusting the temperature and length of the heat and cold sources to match the temperatures at the end of the two adiabatic processes, the working gas at each end undergoes the four reversible processes in one rotation, conforming to the definition of the Carnot cycle.",
        rotate_p5: "The piston does work on the cylinder's rotation on the left side, while the cylinder does work on the piston on the right side. Since the temperature is higher on the right side, the piston's trajectory is more on the left side and further from the origin, so the net work done by the piston on the cylinder in continuous rotation is counter-clockwise, which can maintain the cylinder's rotation and do external work.",
        rotate_pump: "Rotary Heat Pump",
        rotate2_p1: "The cylinder is driven to rotate on a vertical plane by an external force. The gravity of the piston compresses the gas below. As it rotates to the bottom, it leaves the heat source and begins an <b>adiabatic expansion</b> process, gradually cooling down.",
        rotate2_p2: "On the left side, it enters the cold source, whose temperature is the same as the cooled gas, and undergoes an <b>isothermal expansion</b> process, absorbing heat from the cold source. At the highest point, it leaves the cold source and begins an <b>adiabatic compression</b> process, gradually heating up.",
        rotate2_p3: "On the right side, it enters the heat source, whose temperature is the same as the heated gas, and begins an <b>isothermal compression</b> process, releasing heat to the heat source.",
        rotate2_p4: "By adjusting the temperature and length of the heat and cold sources to match the temperatures at the end of the two adiabatic processes, the working gas at each end undergoes the four reversible processes in one rotation, conforming to the definition of the inverse Carnot cycle.",
        rotate2_p5: "The piston does work on the cylinder's rotation on the right side, while the cylinder does work on the piston on the left side. Since the temperature is higher on the right side, the piston's trajectory is more on the left side and further from the origin, thus requiring external work to maintain operation.",
        reciprocate_engine: "Reciprocating Heat Engine",
        reciprocate_p1: "The reciprocating cylinder can move left and right. When the piston inside it reciprocates, the cylinder moves in the opposite direction, keeping their total momentum zero. The amplitude is inversely proportional to their mass.",
        reciprocate_p2: "When the working gas on one side is compressed to its highest temperature, a heat source of the same temperature is applied. Simultaneously, the other side expands to its lowest temperature, and a cold source of the same temperature is applied. Both sides then undergo isothermal expansion/compression processes.",
        reciprocate_p3: "After removing the heat/cold sources, both sides undergo adiabatic expansion/compression until they reach the extreme position in the other direction. Then, the cold/heat sources are applied in reverse, and both sides undergo isothermal compression/expansion.",
        reciprocate_p4: "After removing the cold/heat sources, both sides undergo adiabatic compression/expansion. Within each cycle, the working gas on each side experiences the four processes of the Carnot cycle.",
        reciprocate_p5: "External work is done through the movement of the cylinder.",
        ring_engine: "Ring-Kinetic Heat Engine",
        ring_p1: "The cylinder is a ring-shaped tube with two valves, always one open and one closed. Two straight pipes also have a valve at each end. All valves are green for open and red for closed. The state of the valves on the straight pipes is always opposite to the nearest ring valve.",
        ring_p2: `At any moment, the cylinder's path starts from a red valve on one straight pipe, passes through three green valves, makes a full circle, and reaches the red valve on the other straight pipe, shaped like <span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g>
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>.`,
        ring_p3: `The ring tube rotates half a circle, and the valves switch simultaneously. Before each switch, the tube is shaped like <span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g transform="scale(-1, 1)">
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>, opening to the left, and after the switch, it becomes <span style="font-size: 24px;">
                        <svg class="inline-svg" viewBox="-5.58 -2.37 10 5.48" xmlns="http://www.w3.org/2000/svg">
                            <g>
                                <path d="M 3.42 1.37 A 4 4 0 1 1 3.42 -1.37 L -1.58 -1.37 M 3.42 1.37 L -1.58 1.37" fill="none" stroke="blue" stroke-width="1" stroke-linecap="round" stroke-linejoin="round"/>
                            </g>
                        </svg>
                        </span>.`,
        ring_p4: "There is a high-density liquid column at the bottom of the ring tube. Since the tube is rotatable and light, the liquid column always stays at the bottom when there is no load. Different gas pressures on both sides of the liquid column drive the ring tube to rotate.",
        ring_p5: "After each valve switch, a heat source is applied to the lower straight pipe and a cold source to the upper one. The gas on the right side of the liquid column (hot pipe) undergoes isothermal expansion, while the gas on the left side (cold pipe) undergoes isothermal compression.",
        ring_p6: "After removing the heat and cold sources, the ring tube continues to rotate due to inertia. The gas on the right side undergoes adiabatic expansion, and the gas on the left side undergoes adiabatic compression. The use of inertia is similar to that in a reciprocating engine.",
        ring_p7: "After the green ring valve leaves the liquid column area, the valves switch, the original compression end becomes the expansion end, and the original expansion end becomes the compression end, starting the next cycle.",
        ring_p8: "External work is done through the rotation of the cylinder.",
        ring_p9: "This engine can flexibly adapt to variable loads. The greater the load, the more the liquid column's position shifts to the left.",
        empty_engine: "Empty-Tube Heat Engine",
        isothermal_compression: "Isothermal Compression",
        adiabatic_expansion: "Adiabatic Expansion",
        adiabatic_compression: "Adiabatic Compression",
        isothermal_expansion: "Isothermal Expansion",
        empty_p1: "The ring tube has no piston and is filled with high-pressure, high-density working gas. The gas's own weight creates pressure, causing the gas at the bottom to heat up.",
        empty_p2: "There are twelve valves in the ring tube. Each valve closes between the seven o'clock and six o'clock positions and opens otherwise. At any given time, at least one valve is closed.",
        empty_p3: "Each time the valve at the six o'clock position opens, the gas in the six to seven o'clock section comes into contact with a heat source of the same temperature. This gas then moves upward, expands due to decreasing pressure, and absorbs heat from the source, undergoing an isothermal expansion process.",
        empty_p4: "After leaving the heat source, it continues to rise and expand, undergoing an adiabatic expansion process and cooling down.",
        empty_p5: "At the top, it comes into contact with a cold source of the same temperature. It then moves downward, is compressed by increasing pressure, and releases heat to the cold source, undergoing an isothermal compression process.",
        empty_p6: "After leaving the cold source, it continues to descend and be compressed, undergoing an adiabatic compression process and heating up, thus completing the Carnot cycle.",
        empty_p7: "The left half has a lower temperature, so the pressure on the left side of the closed valve is always greater, pushing the ring tube to rotate counter-clockwise and do external work. Alternatively, the valves can be omitted and a turbine added inside the ring tube to generate electricity.",
        empty_p8: "Since the density of gas is difficult to match that of liquids and solids, it can only operate in the Carnot cycle mode under conditions of large size and small temperature differences. If these conditions are not met, it operates in the Brayton cycle.",
        "switch": "Thermal Switch",
        switch_p1: "All the previous Carnot engines face the problem of thermal switching. The cylinder is sometimes thermally conductive and sometimes adiabatic. Due to the large specific heat capacity of real solid materials, thermal switching causes significant losses.",
        switch_p2: "This is an efficient switching solution. There is a fixed chamber on each side of the cylinder. The left side is a hot chamber, kept at a high temperature; the right side is a cold chamber, kept at a low temperature.",
        switch_p3: "There are two channels between the cylinder and each chamber. The front two channels have valves. The rear two channels each have a piston to ensure that the pressure in the three chambers is always equal.",
        switch_p4: "When both valves are closed, the gas in the cylinder is in an adiabatic process. When the left valve is open, the cylinder is connected to the hot chamber for isothermal expansion; when the right valve is open, the cylinder is connected to the cold chamber for isothermal compression.",
        switch_p5: "A flywheel helps to understand the periodic motion of the piston. If a real engine were built this way, the airtightness of the piston might be a major challenge. The recommended use is as one end of a rotary or reciprocating cylinder, and it can also be used in a ring-type engine.",
        physical_models: "Physical Models",
        model_intro: "These models use water as the piston, which has high airtightness and low resistance. They are suitable for low-temperature difference scenarios (around 5 degrees). To adapt to high-temperature difference industrial scenarios, the size of the turntable should be increased, and a high-density liquid should be used to approximate the Carnot cycle.",
        video1_title: "Fork-Tube Rotary Carnot Engine",
        video2_title: "Low-Temperature Difference Full-Tube Rotary Carnot Engine",
        video3_title: "Ring-Kinetic Carnot Engine"
    }
};

let currentLang = localStorage.getItem('lang') || 'zh';

function setLanguage(lang) {
    currentLang = lang;
    localStorage.setItem('lang', lang);
    const elements = document.querySelectorAll('[data-lang-key]');
    elements.forEach(el => {
        const key = el.getAttribute('data-lang-key');
        if (translations[lang] && translations[lang][key]) {
            el.innerHTML = translations[lang][key];
        }
    });
    document.documentElement.lang = lang;
    document.title = translations[lang].title;
    document.getElementById('lang-toggle').innerText = lang === 'zh' ? 'English' : '中文';
}

document.getElementById('lang-toggle').addEventListener('click', () => {
    const newLang = currentLang === 'zh' ? 'en' : 'zh';
    setLanguage(newLang);
});

// Initial language setup
setLanguage(currentLang);

class Carnot
{
    constructor( Id, isEngine )
    {
        let self = this;
        this.Div = document.getElementById( Id );
        this.Canvas = this.Div.querySelector( 'canvas' );
        this.Div.querySelector( 'button' ).onclick = () => self.Run ? self.Stop() : self.Start();
        this.Div.onmouseover = () =>
        {
            if( this.Run < 0 )
            {
                this.Run = 0;
                this.Start();
                this.Stop();
            }
        }
        if( typeof( THREE ) === "undefined")
        {
            this.CTX = this.Canvas.getContext( '2d' );
        }
        else
        {
            let loop = async () =>
            {
                if( this.Run === 0 )
                {
                    this.StaticProcess();
                }
                await new Promise( r => setTimeout( r, this.Interval * 8 ));
                loop();
            };
            
            loop();
        }
        
        this.Angle = 0;
        this.Interval = 40;
        this.Run = -1;
        this.IsEngine = isEngine;
    }

    async Start()
    {
        if( this.Run > 0 )
        {
            return;
        }

        this.Run = 1;
        this.Div.querySelector( 'button' ).innerText = 'Stop';

        let loop = async () =>
        {
            this.StaticProcess();
            if( this.Run === 0 )
            {
                console.log( "Stopping animation loop." );
                await new Promise( r => setTimeout( r, this.Interval * 4 ));
                return;
            }
            else
            {
                this.Draw();
                this.Angle += this.IsEngine ? 0.01 : -0.01;
                if( this.Angle < 0 )
                {
                    this.Angle += Math.PI * 2;
                }
                else if( this.Angle >= Math.PI * 2 )
                {
                    this.Angle -= Math.PI * 2;
                }
            }
            await new Promise( r => setTimeout( r, this.Interval ));
            loop(); // Continue loop
        };

        loop();
    }

    StaticProcess()
    {
        if( this.Controls )
        {
            this.Controls.update();
            if( this.Run === 0 && this.renderer )
            {
                this.renderer.setClearColor( 0xebedaf );
                this.renderer.render( this.scene, this.camera );
            }
        }
    }

    Draw()
    {
        return typeof( THREE ) !== "undefined" ? this.Draw3d() : this.Draw2d();
    }

    Stop()
    {
        this.Run = 0;
        this.Div.querySelector( 'button' ).innerText = 'Start';
    }
}

class ReciEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );
        // --- 3D Specific Setup ---
        if( typeof( THREE ) !== "undefined" )
        {
            this.scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight; // Use window aspect ratio
            this.camera = new THREE.PerspectiveCamera( 75, 15 / 7, 0.1, 1000 );
            this.camera.position.set( 0, 0, 25 ); // Position camera
            this.camera.aspect = 15 / 7;
            this.camera.position.z = 50;
            this.camera.fov = 20;
            this.camera.updateProjectionMatrix();

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
            this.scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );
            directionalLight.position.set( 10, 15, 20 );
            this.scene.add( directionalLight );

            this.CYLINDER_LENGTH = 20; // 无量纲，只表示比例
            this.CYLINDER_RADIUS = 2;
            this.PISTON_HEIGHT = 2;

            this.SetupObjects(); // Creates meshes and defines constants
            const [width, height] = [this.Canvas.width, this.Canvas.height];
            console.log( width, height );
            this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
            this.renderer.setSize( width, height );

            if( typeof THREE.OrbitControls !== 'undefined' )
            {
                this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
            }
        }
        else
        {
            this.Center = [Math.floor( this.Canvas.width / 2 ), Math.floor( this.Canvas.height / 2 )];
            this.LinderLength = 300;
            this.LinderWidth = 40;
            this.Interval = 24;
            this.Angle = 0;
            this.Base = { x: 150, y: 120 };
        }
        this.Draw();
    }

    SetupObjects()
    {
        // Create rotating group
        this.CyldGroup = new THREE.Group();
        this.scene.add( this.CyldGroup );

        // Create cylinder
        const cylinderGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS, this.CYLINDER_RADIUS, this.CYLINDER_LENGTH, 32, 1, true );
        const cylinderMaterial = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, transparent: true, opacity: 0.6, side: THREE.DoubleSide
        } );
        const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
        this.CyldGroup.add( cylinder );

        // Create caps
        const capGeometry = new THREE.CircleGeometry( this.CYLINDER_RADIUS, 32 );
        const capMaterial = new THREE.MeshPhongMaterial( { color: 0x666666 } );
        const topCap = new THREE.Mesh( capGeometry, capMaterial );
        topCap.position.y = this.CYLINDER_LENGTH / 2;
        topCap.rotation.x = Math.PI / 2;
        this.CyldGroup.add( topCap );
        const bottomCap = new THREE.Mesh( capGeometry, capMaterial );
        bottomCap.position.y = -this.CYLINDER_LENGTH / 2;
        bottomCap.rotation.x = -Math.PI / 2;
        this.CyldGroup.add( bottomCap );

        // Create piston
        const pistonGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS - 0.1, this.CYLINDER_RADIUS - 0.1, this.PISTON_HEIGHT, 32 );
        const pistonMaterial = new THREE.MeshPhongMaterial( { color: 0x444444 } );
        this.piston = new THREE.Mesh( pistonGeometry, pistonMaterial ); // Store piston reference
        this.CyldGroup.add( this.piston );

        this.CyldGroup.rotation.z = Math.PI / 2;

        const HotGeometry = new THREE.PlaneGeometry( 3, 1 );
        const HotMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        const ColdMaterial = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
        this.HotSrc = new THREE.Mesh( HotGeometry, HotMaterial );
        this.ColdSrc = new THREE.Mesh( HotGeometry, ColdMaterial );
        this.HotSrc.position.y = this.ColdSrc.position.y = -3;
        //this.LeftSrc.visible = false;
        this.HotSrc.position.x = -9;
        this.ColdSrc.position.x = 9;
        //hotArc.position.z = -1; // Push back slightly
        this.scene.add( this.HotSrc );
        this.scene.add( this.ColdSrc );

        this.scene.add( new THREE.AxesHelper( 12 ));
    }

    Draw3d()
    {
         if( !this.renderer || !this.scene || !this.camera )
         {
             console.log( "Renderer, scene, or camera not ready for Draw.", this.renderer, this.scene, this.camera );
             return;
         }

        if ( !this.piston ) return; // Guard clause

        //const [Sin, Cos] = [Math.sin( this.Angle ), Math.cos( this.Angle )];
        const Offset = Math.sin( this.Angle );
        this.CyldGroup.position.x = Offset * this.CYLINDER_LENGTH / 8;
        this.piston.position.y = Offset * this.CYLINDER_LENGTH / 4;

        if( this.Run > 0 )
        {
            const TextDoms = Array.from( this.Div.querySelectorAll( '.canvtext' ));
            const Quadrant = Math.floor( this.Angle / Math.PI * 2 ) % 4;
            const stagesZh = [['绝热压缩', '绝热膨胀'], ['等温膨胀', '等温压缩'], ['绝热膨胀', '绝热压缩'], ['等温压缩', '等温膨胀']];
            const stagesEn = [['Adiabatic Comp.', 'Adiabatic Exp.'], ['Isothermal Exp.', 'Isothermal Comp.'], ['Adiabatic Exp.', 'Adiabatic Comp.'], ['Isothermal Comp.', 'Isothermal Exp.']];
            const stages = currentLang === 'zh' ? stagesZh[Quadrant] : stagesEn[Quadrant];

            this.HotSrc.position.x = [50, -6, 50, 6][Quadrant];
            this.ColdSrc.position.x = [50, 9, 50, -9][Quadrant];

            TextDoms[0].innerText = (currentLang === 'zh' ? '左侧：' : 'Left: ') + stages[0];
            TextDoms[1].innerText = (currentLang === 'zh' ? '右侧：' : 'Right: ') + stages[1];
            TextDoms.forEach( t => t.style.display = 'block' );
        }

        // Render the 3D scene
        //if( this.Controls )
        //{
            //this.Controls.update();
        //}
        this.renderer.setClearColor( 0xebedaf );
        this.renderer.render( this.scene, this.camera );
    }

    Draw2d()
    {
        this.CTX.clearRect( 0, 0, this.Canvas.width, this.Canvas.height );

        this.CTX.beginPath();       //中线
        this.CTX.moveTo( this.Center[0], 50 );
        this.CTX.lineTo( this.Center[0], 250 );
        this.CTX.lineWidth = 2;
        this.CTX.strokeStyle = 'lightgray';
        this.CTX.stroke();

        this.CTX.strokeStyle = 'black';    //气缸
        this.CTX.lineWidth = 2;
        this.CTX.fillStyle = 'white';
        const offset = Math.sin( this.Angle ) * 40;
        this.CTX.fillRect( this.Base.x + offset + 1, this.Base.y + 1, this.LinderLength - 2, this.LinderWidth - 2 );
        this.CTX.strokeRect( this.Base.x + offset, this.Base.y, this.LinderLength, this.LinderWidth );

        this.CTX.fillStyle = 'darkgray';
        this.CTX.fillRect( this.Canvas.width / 2 - 20 - offset * 0.8, this.Base.y, 40, this.LinderWidth );

        const Angle = this.Angle % ( Math.PI * 2 );
        let stage = '绝热';
        if( Angle < Math.PI && Angle > Math.PI * 0.5 )
        {
            stage = '等温';
            this.CTX.fillStyle = 'red';
            this.CTX.fillRect( 180, this.Base.y + 45, 50, 20 );
            this.CTX.fillStyle = 'blue';
            this.CTX.fillRect( 420, this.Base.y + 45, 50, 20 );
        }
        else if( Angle < Math.PI * 2 && Angle > Math.PI * 1.5 )
        {
            stage = '等温';
            this.CTX.fillStyle = 'red';
            this.CTX.fillRect( 370, this.Base.y + 45, 50, 20 );
            this.CTX.fillStyle = 'blue';
            this.CTX.fillRect( 130, this.Base.y + 45, 50, 20 );
        }

        const Status = Number( Angle < Math.PI * 1.5 && Angle > Math.PI * 0.5 );
        this.CTX.fillStyle = 'black';
        this.CTX.font = '16px Arial';
        this.CTX.fillText( stage + ['压缩','膨胀'][Status], 180, 80 );
        this.CTX.fillText( stage + ['膨胀','压缩'][Status], 360, 80 );
    }
}

class RotEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );

        // --- 3D Specific Setup ---
        if( typeof( THREE ) !== "undefined" )
        {
            this.scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight; // Use window aspect ratio
            this.camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            this.camera.position.set( 0, 0, 25 ); // Position camera
            this.camera.aspect = 1;
            this.camera.updateProjectionMatrix();

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
            this.scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );
            directionalLight.position.set( 10, 15, 20 );
            this.scene.add( directionalLight );

            this.CYLINDER_LENGTH = 24; // 无量纲，只表示比例
            this.CYLINDER_RADIUS = 2;
            this.PISTON_HEIGHT = 2;

            this.SetupObjects(); // Creates meshes and defines constants
            const [width, height] = [this.Canvas.innerWidth, this.Canvas.innerHeight];
            this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
            this.renderer.setSize( 400, 400 );

            if( typeof THREE.OrbitControls !== 'undefined' )
            {
                this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
            }
            this.DiffAngle = 0.01;
            this.OldPistonPos = 0;
        }
        else
        {
            this.Center = [Math.floor( this.Canvas.width / 2 ), Math.floor( this.Canvas.height / 2 )];
            this.LinderLength = 280;
            this.LinderWidth = 30;
            this.Radius = 150;
        }
        this.Draw();
    }

    SetupObjects()
    {
        // Create rotating group
        this.rotatingGroup = new THREE.Group();
        this.scene.add( this.rotatingGroup );

        // Create cylinder
        const cylinderGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS, this.CYLINDER_RADIUS, this.CYLINDER_LENGTH, 32, 1, true );
        const cylinderMaterial = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, transparent: true, opacity: 0.6, side: THREE.DoubleSide
        } );
        const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
        this.rotatingGroup.add( cylinder );

        // Create caps
        const capGeometry = new THREE.CircleGeometry( this.CYLINDER_RADIUS, 32 );
        const capMaterial = new THREE.MeshPhongMaterial( { color: 0x666666 } );
        const topCap = new THREE.Mesh( capGeometry, capMaterial );
        topCap.position.y = this.CYLINDER_LENGTH / 2;
        topCap.rotation.x = Math.PI / 2;
        this.rotatingGroup.add( topCap );
        const bottomCap = new THREE.Mesh( capGeometry, capMaterial );
        bottomCap.position.y = -this.CYLINDER_LENGTH / 2;
        bottomCap.rotation.x = -Math.PI / 2;
        this.rotatingGroup.add( bottomCap );

        // Create piston
        const pistonGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS - 0.1, this.CYLINDER_RADIUS - 0.1, this.PISTON_HEIGHT, 32 );
        const pistonMaterial = new THREE.MeshPhongMaterial( { color: 0x444444 } );
        this.piston = new THREE.Mesh( pistonGeometry, pistonMaterial ); // Store piston reference
        this.rotatingGroup.add( this.piston );

        // Heat Source / Cold Source Indicators ( Arcs )
        const arcRadius = this.CYLINDER_LENGTH * 0.6; // Adjust radius as needed
        const hotArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, 3 * Math.PI / 2, 2 * Math.PI, false ).getPoints( 50 )
        );
        const hotArcMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 3 } );
        const hotArc = new THREE.Line( hotArcGeometry, hotArcMaterial );
        hotArc.position.z = -1; // Push back slightly
        this.scene.add( hotArc );

        const coldArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, Math.PI / 2, Math.PI, false ).getPoints( 50 )
        );
        const coldArcMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff, linewidth: 3 } );
        const coldArc = new THREE.Line( coldArcGeometry, coldArcMaterial );
        coldArc.position.z = -1; // Push back slightly
        this.scene.add( coldArc );

        this.scene.add( new THREE.AxesHelper( 12 ));
    }

    Draw3d()
    {
         if( !this.renderer || !this.scene || !this.camera )
         {
             console.log( "Renderer, scene, or camera not ready for Draw.", this.renderer, this.scene, this.camera );
             return;
         }

        // Update objects based on state ( this.Angle )
        if( this.rotatingGroup )
        {
            this.rotatingGroup.rotation.z = this.Angle;
        }

        if ( !this.piston ) return; // Guard clause

        const [Sin, Cos] = [Math.sin( this.Angle ), Math.cos( this.Angle )];
        const Offset = -Cos * ( Sin * Cos > 0 ? 1.2 : 0.8 ) + ( Sin > 0 ? 0.2 : -0.2 );
        this.piston.position.y = Offset * this.CYLINDER_LENGTH / 4;

        if( this.Run > 0 )
        {
            const TextDoms = Array.from( this.Div.querySelectorAll( '.canvtext' ));
            const stage = Sin * Cos > 0 ? (currentLang === 'zh' ? '等温' : 'Isothermal') : (currentLang === 'zh' ? '绝热' : 'Adiabatic');
            const action1 = this.IsEngine ? (currentLang === 'zh' ? '压缩' : 'Comp.') : (currentLang === 'zh' ? '膨胀' : 'Exp.');
            const action2 = this.IsEngine ? (currentLang === 'zh' ? '膨胀' : 'Exp.') : (currentLang === 'zh' ? '压缩' : 'Comp.');

            TextDoms[0].innerText = (currentLang === 'zh' ? '左侧：' : 'Left: ') + stage + action1;
            TextDoms[1].innerText = (currentLang === 'zh' ? '右侧：' : 'Right: ') + stage + action2;

            if (Offset * Sin > 0) {
                TextDoms[2].innerText = this.IsEngine ? (currentLang === 'zh' ? '气缸对活塞做功' : 'Cylinder does work on piston') : (currentLang === 'zh' ? '活塞对气缸做功' : 'Piston does work on cylinder');
                TextDoms[2].style.left = '80px';
                this.DiffAngle += 0.0001;
            } else {
                TextDoms[2].innerText = this.IsEngine ? (currentLang === 'zh' ? '活塞对气缸做功' : 'Piston does work on cylinder') : (currentLang === 'zh' ? '气缸对活塞做功' : 'Cylinder does work on piston');
                TextDoms[2].style.left = '210px';
                this.DiffAngle += -0.0001;
            }

            TextDoms.forEach( t => t.style.display = 'block' );

            if( this.IsEngine )
            {
                if( this.OldPistonPos < 0 && Offset * Sin > 0 )
                {
                    this.DiffAngle = 0;
                }
                this.Angle += this.DiffAngle;
                this.OldPistonPos = Offset * Sin;
            }
        }

        //if( this.Controls )
        //{
            //this.Controls.update();
        //}
        this.renderer.setClearColor( 0xebedaf );
        this.renderer.render( this.scene, this.camera );
    }

    Draw2d()
    {
        this.CTX.clearRect( 0, 0, this.Canvas.width, this.Canvas.height );

        this.CTX.beginPath();       //中线
        this.CTX.moveTo( this.Center[0], 50 );
        this.CTX.lineTo( this.Center[0], 350 );
        this.CTX.lineWidth = 2;
        this.CTX.strokeStyle = 'lightgray';
        this.CTX.stroke();

        this.CTX.lineWidth = 10;
        this.CTX.beginPath();       //热源
        this.CTX.arc( this.Center[0], this.Center[1], this.Radius, 0, Math.PI / 2, false );
        this.CTX.strokeStyle = 'red';
        this.CTX.stroke();

        this.CTX.beginPath();       //冷源
        this.CTX.arc( this.Center[0], this.Center[1], this.Radius, Math.PI, -Math.PI / 2, false );
        this.CTX.strokeStyle = 'blue';
        this.CTX.stroke();

        this.CTX.save();    //绘制旋转的气缸
        this.CTX.translate( ...this.Center );
        this.CTX.rotate( -this.Angle ); //逆时针旋转
        this.CTX.strokeStyle = 'black';    //绘制无填充色的矩形，仅有黑色边框
        this.CTX.lineWidth = 2;
        this.CTX.strokeRect( -this.LinderWidth / 2, -this.LinderLength / 2, this.LinderWidth, this.LinderLength );

        let Offset, stage;    // 计算活塞位置
        const Angle = this.Angle % ( Math.PI * 2 );
        if( Angle % Math.PI <= Math.PI / 2 )
        {    // 从最下方 0 ~ pi/2
            Offset = Math.cos( Angle ) * this.LinderLength / 3 - 26 * [1, -1][Number( Angle >= Math.PI )];
            stage = '等温';
        }
        else
        {   // pi/2 ~ pi
            Offset = Math.cos( Angle ) * ( this.LinderLength - 156 ) / 3 - 26 * [1, -1][Number( Angle >= Math.PI )];
            stage = '绝热';
        }
        this.CTX.fillStyle = 'darkgray';
        this.CTX.fillRect( -this.LinderWidth/2, Offset - 10, this.LinderWidth, 20 );
        this.CTX.restore();

        // 标记卡诺循环阶段
        this.CTX.fillStyle = 'black';
        this.CTX.font = '16px Arial';
        const Index = Number( this.IsEngine );
        this.CTX.fillText( `${ stage }压缩`, [300, 20][Index], 40 );
        this.CTX.fillText( `${ stage }膨胀`, [20, 300][Index], 40 );
        this.CTX.fillText( [['气缸对活塞做功', '      活塞对气缸做功'], ['活塞对气缸做功', '      气缸对活塞做功']][Index][Number( Offset * ( Angle - Math.PI ) < 0 && Angle % Math.PI <= Math.PI / 2 )], 130, 380 );
    }
}

class RingEngine extends Carnot
{
    constructor(Id, isEngine)
    {
        super(Id, isEngine);

        // 3D环管式热机的参数
        this.mainRadius = 8;
        this.pipeRadius = 0.8;
        this.connectionAngleOffsetDeg = 30;
        this.mainValveSize = 1.2;
        this.smallValveSize = 0.8;
        this.smallValveOffsetRatio = 0.02;
        //this.rotationSpeed = 1.0;
        this.DiffAngle = 0;
        this.liquidLengthRad = Math.PI; // 180度液体区域
        this.activeZoneStartRad = Math.PI; // 从π开始
        this.activeZoneEndRad = 2 * Math.PI; // 到2π结束

        // 阀门角度位置
        this.mainValveAngles = [0, Math.PI]; // 主阀门在0度和180度

        // 状态变量
        this.currentMainValve1State = true;
        this.curPipeState = false;

        // 存储网格对象
        this.mainValveMeshes = [];
        this.smallValveMeshes = [];
        this.pipes = [];

        // --- 3D 设置 ---
        if (typeof(THREE) !== "undefined")
        {
            this.setupScene();
            this.setupObjects();
            this.scene.add( new THREE.AxesHelper( 12 ));
        }
        else
        {
            console.log('RingEngine 仅支持 3D 模式');
        }

        if( typeof THREE.OrbitControls !== 'undefined' )
        {
            this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
        }

        this.Draw();
    }

    setupScene()
    {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xffffdd);

        this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        this.camera.position.set( this.mainRadius * -0.1, this.mainRadius * 0.2, this.mainRadius * 2.5 );
        //this.camera.lookAt(1, 2, 3);

        this.renderer = new THREE.WebGLRenderer({canvas: this.Canvas, antialias: true});
        this.renderer.setSize(this.Canvas.width, this.Canvas.height);

        // 材质
        this.valveClosedMaterial = new THREE.MeshStandardMaterial({
            color: 0xcc4444, metalness: 0.6, roughness: 0.4
        });
        this.valveOpenMaterial = new THREE.MeshStandardMaterial({
            color: 0x44cc44, metalness: 0.6, roughness: 0.4
        });
        this.ringMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa, metalness: 0.5, roughness: 0.5,
            transparent: true, opacity: 0.5, side: THREE.DoubleSide
        });
        this.pipeMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666, metalness: 0.5, roughness: 0.5
        });
        this.liquidMaterial = new THREE.MeshStandardMaterial({
            color: 0x1bc4c8, metalness: 0.1, roughness: 0.4, side: THREE.DoubleSide
        });
        this.hotMaterial = new THREE.MeshStandardMaterial({
            color: 0xff4444, metalness: 0.3, roughness: 0.3
        });
        this.coldMaterial = new THREE.MeshStandardMaterial({
            color: 0x4444ff, metalness: 0.3, roughness: 0.3
        });

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(5, 10, 7);
        this.scene.add(directionalLight);

        this.clock = new THREE.Clock();
    }

    setupObjects()
    {
        // 创建旋转组
        this.rotatingGroup = new THREE.Group();
        this.scene.add(this.rotatingGroup);

        // 1. 主环管
        const ringGeometry = new THREE.TorusGeometry(this.mainRadius, this.pipeRadius, 32, 100);
        const ringMesh = new THREE.Mesh(ringGeometry, this.ringMaterial);
        ringMesh.rotation.x = Math.PI / 2;
        this.rotatingGroup.add(ringMesh);

        // 2. 主阀门
        const initialValve1InZone = this.isAngleInActiveZone(this.mainValveAngles[0]);
        const initialValve2InZone = this.isAngleInActiveZone(this.mainValveAngles[1]);
        this.currentMainValve1State = initialValve1InZone || !initialValve2InZone;

        const mainValvePos1 = new THREE.Vector3(this.mainRadius, 0, 0);
        const mainValve1 = this.createValve(
            mainValvePos1,
            this.mainValveSize,
            this.mainValveSize * 0.6,
            !this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial,
            true
        );
        mainValve1.rotation.z += Math.PI / 2;
        this.rotatingGroup.add(mainValve1);
        this.mainValveMeshes.push(mainValve1);

        const mainValvePos2 = new THREE.Vector3(-this.mainRadius, 0, 0);
        const mainValve2 = this.createValve(
            mainValvePos2,
            this.mainValveSize,
            this.mainValveSize * 0.6,
            this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial,
            true
        );
        mainValve2.rotation.z += Math.PI / 2;
        this.rotatingGroup.add(mainValve2);
        this.mainValveMeshes.push(mainValve2);

        // 3. 连接点和直管
        const offsetAngleRad = THREE.MathUtils.degToRad(this.connectionAngleOffsetDeg) * 0.37;
        const angleP1 = offsetAngleRad;
        const angleP2 = -offsetAngleRad;
        const angleP3 = Math.PI - offsetAngleRad;
        const angleP4 = Math.PI + offsetAngleRad;

        const P1 = new THREE.Vector3(this.mainRadius * Math.cos(angleP1) * 0.9, 0, -this.mainRadius * Math.sin(angleP1));
        const P2 = new THREE.Vector3(this.mainRadius * Math.cos(angleP2) * 0.9, 0, -this.mainRadius * Math.sin(angleP2));
        const P3 = new THREE.Vector3(this.mainRadius * Math.cos(angleP3) * 0.9, 0, -this.mainRadius * Math.sin(angleP3));
        const P4 = new THREE.Vector3(this.mainRadius * Math.cos(angleP4) * 0.9, 0, -this.mainRadius * Math.sin(angleP4));

        // 4. 直管
        const straightPipe1 = this.createPipe(P2, P4, this.pipeRadius * 0.9, this.pipeMaterial);
        this.rotatingGroup.add(straightPipe1);
        this.pipes.push(straightPipe1);

        const straightPipe2 = this.createPipe(P1, P3, this.pipeRadius * 0.9, this.pipeMaterial);
        this.rotatingGroup.add(straightPipe2);
        this.pipes.push(straightPipe2);

        // 5. 小阀门
        const dirPipe1 = new THREE.Vector3().subVectors(P4, P2).normalize();
        const dirPipe2 = new THREE.Vector3().subVectors(P3, P1).normalize();
        const pipe1Length = P2.distanceTo(P4) * 0.3;
        const pipe2Length = P1.distanceTo(P3) * 0.3;

        const svPos1 = new THREE.Vector3().addVectors(P2, dirPipe1.clone().multiplyScalar(pipe1Length * this.smallValveOffsetRatio));
        const svPos2 = new THREE.Vector3().addVectors(P4, dirPipe1.clone().multiplyScalar(-pipe1Length * this.smallValveOffsetRatio));
        const svPos3 = new THREE.Vector3().addVectors(P1, dirPipe2.clone().multiplyScalar(pipe2Length * this.smallValveOffsetRatio));
        const svPos4 = new THREE.Vector3().addVectors(P3, dirPipe2.clone().multiplyScalar(-pipe2Length * this.smallValveOffsetRatio));

        const sv1_isOpen = this.currentMainValve1State;
        const sv2_isOpen = !this.currentMainValve1State;
        const sv3_isOpen = this.currentMainValve1State;
        const sv4_isOpen = !this.currentMainValve1State;

        const smallValve1 = this.createValve(svPos1, this.smallValveSize, this.smallValveSize * 0.6,
            sv1_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe1);
        this.rotatingGroup.add(smallValve1);
        this.smallValveMeshes.push(smallValve1);

        const smallValve2 = this.createValve(svPos2, this.smallValveSize, this.smallValveSize * 0.6,
            sv2_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe1);
        this.rotatingGroup.add(smallValve2);
        this.smallValveMeshes.push(smallValve2);

        const smallValve3 = this.createValve(svPos3, this.smallValveSize, this.smallValveSize * 0.6,
            sv3_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe2);
        this.rotatingGroup.add(smallValve3);
        this.smallValveMeshes.push(smallValve3);

        const smallValve4 = this.createValve(svPos4, this.smallValveSize, this.smallValveSize * 0.6,
            sv4_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe2);
        this.rotatingGroup.add(smallValve4);
        this.smallValveMeshes.push(smallValve4);

        smallValve1.rotation.z += Math.PI / 2;
        smallValve2.rotation.z += Math.PI / 2;
        smallValve3.rotation.z += Math.PI / 2;
        smallValve4.rotation.z += Math.PI / 2;

        this.rotatingGroup.rotation.x = Math.PI / 2;

        // 6. 液体段
        try {
            const liquidArcGeometry = new THREE.TorusGeometry(
                this.mainRadius,
                this.pipeRadius,
                16, 50,
                this.liquidLengthRad * 0.83
            );
            this.liquidMesh = new THREE.Mesh(liquidArcGeometry, this.liquidMaterial);
            this.liquidMesh.rotation.x = Math.PI;
            this.liquidMesh.rotation.z = Math.PI / 12;;
            this.scene.add(this.liquidMesh);
        } catch(e) {
            console.error("创建液体几何体时出错:", e);
        }
    }

    createValve(position, radius, height, material, isMainValve = false, pipeDirection = null)
    {
        if (radius <= 0 || height <= 0) {
            console.error("阀门尺寸无效:", radius, height);
            return new THREE.Object3D();
        }

        try {
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 20);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);

            if (isMainValve) {
                mesh.lookAt(0, 0, 0);
                mesh.rotateX(Math.PI / 2);
            } else if (pipeDirection && pipeDirection.lengthSq() > 0.0001) {
                const lookAtPos = new THREE.Vector3().addVectors(position, pipeDirection);
                if (lookAtPos.distanceTo(position) < 0.0001) {
                    lookAtPos.add(new THREE.Vector3(0, 1, 0));
                }
                const orientation = new THREE.Matrix4();
                const up = Math.abs(pipeDirection.normalize().y) > 0.99 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
                orientation.lookAt(position, lookAtPos, up);
                mesh.quaternion.setFromRotationMatrix(orientation);
                mesh.rotateY(Math.PI / 2);
            }

            return mesh;
        } catch(e) {
            console.error("创建阀门实例时出错:", e);
            return new THREE.Object3D();
        }
    }

    createPipe(point1, point2, radius, material)
    {
        const direction = new THREE.Vector3().subVectors(point2, point1);
        const length = direction.length();

        if (length < 0.0001) {
            console.warn("管道长度接近零");
            return new THREE.Object3D();
        }
        if (radius <= 0) {
            console.error("管道半径无效:", radius);
            return new THREE.Object3D();
        }

        try {
            const geometry = new THREE.CylinderGeometry(radius, radius, length, 16);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(point1).add(direction.multiplyScalar(0.5));

            const orientation = new THREE.Matrix4();
            const offsetRotation = new THREE.Matrix4();
            const up = Math.abs(direction.normalize().y) > 0.99 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
            orientation.lookAt(point1, point2, up);
            offsetRotation.makeRotationX(Math.PI / 2);
            orientation.multiply(offsetRotation);
            mesh.quaternion.setFromRotationMatrix(orientation);

            return mesh;
        } catch(e) {
            console.error("创建管道实例时出错:", e);
            return new THREE.Object3D();
        }
    }

    normalizeAngle(angle)
    {
        return ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    }

    isAngleInRange(angle, start, end)
    {
        angle = this.normalizeAngle(angle);
        start = this.normalizeAngle(start);
        end = this.normalizeAngle(end);

        if (start <= end) {
            return angle >= start && angle <= end;
        } else {
            return angle >= start || angle <= end;
        }
    }

    isAngleInActiveZone(angle)
    {
        return this.isAngleInRange(angle, this.activeZoneStartRad, this.activeZoneEndRad);
    }

    inHeatingZone(angle)
    {
        return this.isAngleInRange(angle, this.activeZoneStartRad, this.activeZoneEndRad - 1);
    }

    Draw3d()
    {
        if( !this.renderer || !this.scene || !this.camera )
        {
            console.log("渲染器、场景或相机未准备好:", this.renderer, this.scene, this.camera);
            return;
        }

        const delta = this.clock.getDelta();

        // 1. 旋转组
        this.rotatingGroup.rotation.y = this.Angle;
        const currentGroupRotation = this.normalizeAngle(this.rotatingGroup.rotation.y);

        // 2. 确定期望状态
        const worldAngleValve0 = this.normalizeAngle(this.mainValveAngles[0] - currentGroupRotation);
        const worldAngleValve1 = this.normalizeAngle(this.mainValveAngles[1] - currentGroupRotation);
        const valve0InZone = this.isAngleInActiveZone(worldAngleValve0);
        const valve1InZone = this.isAngleInActiveZone(worldAngleValve1);
        const heat = this.Angle % Math.PI < 2;

        let desiredMainValve1State = this.currentMainValve1State;
        if (valve0InZone && !valve1InZone) {
            desiredMainValve1State = true;
        } else if (!valve0InZone && valve1InZone) {
            desiredMainValve1State = false;
        }

        let desiredPipeState = heat;
        if (desiredPipeState !== this.curPipeState) {
            this.curPipeState = desiredPipeState;
            this.pipes[0].material = this.curPipeState ?
                (desiredMainValve1State ? this.hotMaterial : this.coldMaterial) : this.pipeMaterial;
            this.pipes[1].material = this.curPipeState ?
                (!desiredMainValve1State ? this.hotMaterial : this.coldMaterial) : this.pipeMaterial;
        }

        // 3. 更新材质（如果状态改变）
        if (desiredMainValve1State !== this.currentMainValve1State) {
            this.currentMainValve1State = desiredMainValve1State;

            if (this.mainValveMeshes.length === 2) {
                this.mainValveMeshes[0].material = !this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
                this.mainValveMeshes[1].material = this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
            }
            if (this.smallValveMeshes.length === 4) {
                const sv1_sv3_material = this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
                this.smallValveMeshes[0].material = sv1_sv3_material;
                this.smallValveMeshes[2].material = sv1_sv3_material;
                const sv2_sv4_material = !this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
                this.smallValveMeshes[1].material = sv2_sv4_material;
                this.smallValveMeshes[3].material = sv2_sv4_material;
            }
            this.DiffAngle = 0;
        }

        this.DiffAngle += heat ? 0.0002 : -0.0003;
        this.Angle += this.DiffAngle;

        // 4. 更新文本显示

        if( this.Run > 0 )
        {
            const textDoms = Array.from(this.Div.querySelectorAll( '.canvtext' ));
            const heatStr = heat ? (currentLang === 'zh' ? '等温' : 'Isothermal') : (currentLang === 'zh' ? '绝热' : 'Adiabatic');
            if (textDoms.length >= 2) {
                textDoms[0].innerText = (currentLang === 'zh' ? '左侧：' : 'Left: ') + heatStr + (currentLang === 'zh' ? '压缩' : 'Comp.');
                textDoms[1].innerText = (currentLang === 'zh' ? '右侧：' : 'Right: ') + heatStr + (currentLang === 'zh' ? '膨胀' : 'Exp.');
                textDoms.forEach(t => t.style.display = 'block');
            }
        }

        // 5. 渲染
        this.renderer.render( this.scene, this.camera );
    }
}

class EmptyEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );

        // --- 1. 场景初始化 ---
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color( 0xfff0ff );

        this.camera = new THREE.PerspectiveCamera( 45, 1, 0.1, 1000 );
        this.camera.position.set( -10, 10, 135 );

        this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
        this.renderer.setSize( 400, 400 );
        this.renderer.shadowMap.enabled = true;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

        if( typeof THREE.OrbitControls !== 'undefined' )
        {
            this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
            this.Controls.enableDamping = true;
        }

        // --- 2. 灯光系统 ---
        const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
        this.scene.add( ambientLight );

        const mainLight = new THREE.DirectionalLight( 0xffffff, 1.2 );
        mainLight.position.set( 10, 20, 20 );
        mainLight.castShadow = true;
        this.scene.add( mainLight );

        const backLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        backLight.position.set( -10, -10, -10 );
        this.scene.add( backLight );

        // --- 3. 几何体构建 ---
        
        // 3.1 外层环形管
        const tubeRadius = 30;
        const tubeThickness = 5;
        const torusGeometry = new THREE.TorusGeometry( tubeRadius, tubeThickness, 24, 100 );
        
        const torusMaterial = new THREE.MeshPhysicalMaterial( {
            color: 0x88ccff,
            metalness: 0.1,
            roughness: 0.1,
            transmission: 0.7,
            thickness: 1.5,
            transparent: true,
            opacity: 0.4,
            side: THREE.DoubleSide
        } );
        this.torus = new THREE.Mesh( torusGeometry, torusMaterial );
        this.scene.add( this.torus );

        // 3.2 隔板 (阀门)
        const separatorCount = 12;
        this.separators = [];
        this.separatorGroup = new THREE.Group();
        this.scene.add( this.separatorGroup );

        const sepRadius = tubeThickness * 0.92; 
        const sepThickness = 0.3; 
        const cylinderGeo = new THREE.CylinderGeometry( sepRadius, sepRadius, sepThickness, 32 );
        const cylinderMat = new THREE.MeshStandardMaterial( {
            color: 0xffee44,
            roughness: 0.4,
            metalness: 0.3
        } );

        for( let i = 0; i < separatorCount; i++ )
        {
            const angle = ( i / separatorCount ) * Math.PI * 2;
            // --- Pivot (枢轴) ---
            const pivot = new THREE.Object3D();
            pivot.position.x = Math.cos( angle ) * tubeRadius;
            pivot.position.y = Math.sin( angle ) * tubeRadius;
            pivot.rotation.z = angle + Math.PI / 2;

            // --- Valve (隔板本体) ---
            const valve = new THREE.Mesh( cylinderGeo, cylinderMat );

            pivot.add( valve );
            this.separatorGroup.add( pivot );

            this.separators.push( {
                pivot: pivot,
                valve: valve,
                baseAngle: angle
            } );
        }

        const arcRadius = 40; // Adjust radius as needed
        const hotArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, 3 * Math.PI / 2, 2 * Math.PI, false ).getPoints( 50 )
        );
        const hotArcMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 3 } );
        const hotArc = new THREE.Line( hotArcGeometry, hotArcMaterial );
        hotArc.position.z = -1; // Push back slightly
        this.scene.add( hotArc );

        const coldArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, Math.PI / 2, Math.PI, false ).getPoints( 50 )
        );
        const coldArcMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff, linewidth: 3 } );
        const coldArc = new THREE.Line( coldArcGeometry, coldArcMaterial );
        coldArc.position.z = -1; // Push back slightly
        this.scene.add( coldArc );

        this.scene.add( new THREE.AxesHelper( 40 ));
        this.Draw();
    }

    Draw3d()
    {
        if( !this.renderer || !this.scene || !this.camera )
        {
            console.log("渲染器、场景或相机未准备好:", this.renderer, this.scene, this.camera);
            return;
        }

        //const delta = this.clock.getDelta();
        
        const PI = Math.PI;
        const TWO_PI = Math.PI * 2;
        const BOTTOM_ANGLE = -PI / 2; // 6点钟
        const SEGMENT = TWO_PI / 12; 
        const ANGLE_OPEN = 0;
        const ANGLE_CLOSED = Math.PI / 2;
        
        this.separatorGroup.rotation.z = this.Angle;

        this.separators.forEach( item =>
        {
            // 1. 计算当前世界角度
            let currentWorldAngle = ( item.baseAngle + this.Angle ) % TWO_PI;
            
            // 2. 计算与6点钟的距离
            let diff = currentWorldAngle - BOTTOM_ANGLE;
            diff -= diff > PI ? TWO_PI : 0;

            let targetRotation = ANGLE_OPEN; 

            // 3. 状态控制
            if( diff >= -2 * SEGMENT && diff <= -SEGMENT )
            {
                const ratio = Math.abs( diff ) / SEGMENT;
                targetRotation = ANGLE_OPEN * ( 1 - ratio ) + ANGLE_CLOSED * ratio;
            }
            else if( diff > -SEGMENT && diff <= 0 )
            {
                targetRotation = ANGLE_CLOSED;
            }
            else if( diff > 0 && diff <= SEGMENT )
            {
                const ratio = 1 - ( diff - SEGMENT ) / SEGMENT;
                targetRotation = ANGLE_CLOSED * ( 1 - ratio ) + ANGLE_OPEN * ratio;
            }
            else
            {
                targetRotation = ANGLE_OPEN;
            }

            item.valve.rotation.z = targetRotation;
        } );
        
        this.renderer.render( this.scene, this.camera );
    }
}

class ThermalSwitch extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );

        // --- 1. 场景初始化 ---
        const Scene = this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color( 0xfff0ff );

        this.camera = new THREE.PerspectiveCamera( 45, 1, 0.1, 1000 );
        this.camera.position.set( -13, 22, 35 );

        this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
        this.renderer.setSize( 600, 600 );
        this.renderer.shadowMap.enabled = true;
        this.renderer.toneMapping = THREE.ACESFilmicToneMapping;

        if( typeof THREE.OrbitControls !== 'undefined' )
        {
            this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
            this.Controls.enableDamping = true;
            this.Controls.target.set( 0, 7, 0 );
        }

        // --- 2. 灯光系统 ---
        const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
        this.scene.add( ambientLight );

        const mainLight = new THREE.DirectionalLight( 0xffffff, 1.2 );
        mainLight.position.set( 10, 20, 20 );
        mainLight.castShadow = true;
        this.scene.add( mainLight );

        const backLight = new THREE.DirectionalLight( 0xffffff, 0.5 );
        backLight.position.set( -10, -10, -10 );
        this.scene.add( backLight );

        // --- 2. 材质 ---
        const glassMat = new THREE.MeshPhysicalMaterial( {
            color: 0x778899, transmission: 0.8, opacity: 0.3, transparent: true, roughness: 0.1, side: THREE.DoubleSide
        } );
        const metalMat = new THREE.MeshStandardMaterial( { color: 0x888833, roughness: 0.4, metalness: 0.8 } );
        const rodMat = new THREE.MeshStandardMaterial( { color: 0x777055, roughness: 0.5, metalness: 0.5 } );
        
        // 气体 & 阀门材质
        const gasLeftMat = new THREE.MeshBasicMaterial( { color: 0xff3333, transparent: true, opacity: 0.5 } );
        const gasRightMat = new THREE.MeshBasicMaterial( { color: 0x3333ff, transparent: true, opacity: 0.5 } );
        this.gasMidMat = new THREE.MeshBasicMaterial( { color: 0xff3333, transparent: true, opacity: 0.6 } );
        this.valveOpenMat = new THREE.MeshBasicMaterial( { color: 0x00cc00 } );
        const valveClosedMat = this.valveClosedMat = new THREE.MeshBasicMaterial( { color: 0x884622 } );
        const isobaricPistonMat = new THREE.MeshStandardMaterial( { color: 0x000000 } );

        // --- 3. 几何体构建 ---
        // 3.1 腔室
        function createChamber( xPos, material, hasTop, height = 8 )
        {
            const group = new THREE.Group();
            group.position.x = xPos;

            // 玻璃外壳
            const cylGeo = new THREE.CylinderGeometry( 2, 2, height, 32, 1, true );
            const cyl = new THREE.Mesh( cylGeo, glassMat );
            cyl.position.y = height / 2;
            group.add( cyl );

            // 底部/顶部封盖
            const capGeo = new THREE.CylinderGeometry( 2.05, 2.05, 0.2, 32 );
            const capBot = new THREE.Mesh( capGeo, metalMat );
            group.add( capBot );
            
            if( hasTop )
            {
                const capTop = new THREE.Mesh( capGeo, metalMat );
                capTop.position.y = height;
                group.add( capTop );
            }

            // 气体
            const gasGeo = new THREE.CylinderGeometry( 1.9, 1.9, 1, 32 );
            gasGeo.translate( 0, 0.5, 0 ); // 锚点底部
            const gas = new THREE.Mesh( gasGeo, material );
            gas.position.y = 0.1; 
            group.add( gas );

            return { group, gas };
        }

        const leftChamber = createChamber( -6, gasLeftMat, 1 );
        this.midChamber = createChamber( 0, this.gasMidMat, 0 );
        const rightChamber = createChamber( 6, gasRightMat, 1 );
        this.scene.add( leftChamber.group );
        this.scene.add( this.midChamber.group );
        this.scene.add( rightChamber.group );
        
                // 3.2 底部通道系统
        function createBottomPipes( zOffset, isValve, r = 0.3 )
        {
            const group = new THREE.Group();
            group.position.set( 0, 1.0, zOffset ); // 位于Y=1高度

            const pipeGeo = new THREE.CylinderGeometry( r, r, 4, 16 );
            pipeGeo.rotateZ( Math.PI / 2 );
            const leftPipe = new THREE.Mesh( pipeGeo, glassMat );
            leftPipe.position.x = -3;
            const rightPipe = new THREE.Mesh( pipeGeo, glassMat );
            rightPipe.position.x = 3;
            group.add( leftPipe, rightPipe );

            let leftComp, rightComp;
            if( isValve )
            {
                const valveGeo = new THREE.BoxGeometry( 0.5, 0.8, 0.8 );
                leftComp = new THREE.Mesh( valveGeo, valveClosedMat );
                rightComp = new THREE.Mesh( valveGeo, valveClosedMat );
            }
            else
            {
                const isoGeo = new THREE.CylinderGeometry( r * 0.8, r * 0.8, 0.15, 16 );
                isoGeo.rotateZ( Math.PI/2 );
                leftComp = new THREE.Mesh( isoGeo, isobaricPistonMat );
                rightComp = new THREE.Mesh( isoGeo, isobaricPistonMat );
            }
            leftComp.position.x = 3;
            rightComp.position.x = -3;
            group.add( leftComp, rightComp );
            Scene.add( group );
            return { left: leftComp, right: rightComp };
        }
        
        this.valves = createBottomPipes( 1.2, true );
        this.valves.left.scale.set( 0.4, 1.2, 1.2 );
        this.valves.right.scale.set( 0.4, 1.2, 1.2 );
        this.isoPistons = createBottomPipes( -1, false, 0.8 );

        // --- 4. 机械与运动参数设置 ---
        
        // 关键尺寸参数
        const cylinderHeight = 8;
        this.flywheelY = 14.0;   // 飞轮中心高度 (抬高了)
        this.crankRadius = 2.5;  // 曲柄半径
        this.rodLength = 9.0;    // 连杆长度 (加长了)
        
        // 活塞参数
        this.pistonHeight = 1.0; 
        
        // 4.1 飞轮
        this.flywheel = new THREE.Mesh(new THREE.TorusGeometry( 3.5, 0.3, 16, 100 ), metalMat);
        this.flywheel.position.set( 0, this.flywheelY, 0 );
        // 辐条
        this.flywheel.add( new THREE.Mesh( new THREE.BoxGeometry( 0.3, 6.5, 0.2 ), metalMat ));
        const spoke2 = new THREE.Mesh( new THREE.BoxGeometry( 0.3, 6.5, 0.2 ), metalMat );
        spoke2.rotation.z = Math.PI/2;
        this.flywheel.add( spoke2 );
        this.scene.add( this.flywheel );

        // 4.2 曲柄销 (Visual Crank Pin)
        // 这是一个视觉标记，作为飞轮的子物体旋转
        const crankPinVisual = new THREE.Mesh( new THREE.CylinderGeometry( 0.2, 0.2, 1 ), rodMat );
        crankPinVisual.rotation.x = Math.PI/2;
        crankPinVisual.position.set( 0, this.crankRadius, 0.5 ); // 在飞轮上的局部位置
        this.flywheel.add( crankPinVisual );

        // 4.3 活塞 (Piston)
        this.mainPiston = new THREE.Mesh( new THREE.CylinderGeometry( 1.9, 1.9, this.pistonHeight, 32 ), metalMat );
        this.scene.add( this.mainPiston ); // 注意：现在直接放在场景中，通过世界坐标控制

        // 活塞销 (Piston Pin) - 视觉装饰
        const pistonPin = new THREE.Mesh( new THREE.CylinderGeometry( 0.25, 0.25, 1.6 ), rodMat );
        pistonPin.rotation.z = Math.PI/2;
        this.mainPiston.add( pistonPin ); // 跟随活塞

        // 4.4 连杆 (Connecting Rod)
        // 技巧：将几何体向下移动一半长度，这样 Mesh 的原点(0,0,0)就位于连杆的【顶部】
        const rodGeo = new THREE.BoxGeometry( 0.4, this.rodLength, 0.2 );
        rodGeo.translate( 0, -this.rodLength / 2, 0 ); 
        this.rod = new THREE.Mesh( rodGeo, rodMat );
        this.scene.add( this.rod );

        this.scene.add( new THREE.AxesHelper( 10 ));
        this.Draw();
    }

    Draw3d()
    {
        if( !this.renderer || !this.scene || !this.camera )
        {
            console.log("渲染器、场景或相机未准备好:", this.renderer, this.scene, this.camera);
            return;
        }

        // --- 5. 动画与物理计算 ---

        //let angle = 0;
        //const speed = 0.02;
        this.domPhase = document.getElementById('phase-name');
        this.colorHot = new THREE.Color(0xff3333);
        this.colorCold = new THREE.Color(0x3333ff);

        // 辅助向量
        const vCrankPos = new THREE.Vector3();
        const vPistonPos = new THREE.Vector3();

            // 1. 飞轮自转
        this.flywheel.rotation.z = this.Angle;

            // 2. 获取曲柄销的世界坐标
            // 公式: Center + R * [ -sin(a), cos(a) ]  (注意相位和方向)
            // 为了配合逆时针旋转且0度在最高点:
            // x = -sin(angle) * r
            // y = cos(angle) * r
        const crankWorldX = -Math.sin( this.Angle ) * this.crankRadius;
        const crankWorldY = this.flywheelY + Math.cos( this.Angle ) * this.crankRadius;
            
        vCrankPos.set( crankWorldX, crankWorldY, 0.5 ); // z=0.5 稍微靠前避免穿模

            // 3. 解算活塞 Y 位置
            // 连杆长度 L, 水平偏移 dx = crankWorldX
            // 垂直跨度 dy_rod = sqrt(L^2 - dx^2)
            // 活塞销位置 = 曲柄销Y - dy_rod
        const dx = crankWorldX;
        const dyRod = Math.sqrt( this.rodLength * this.rodLength - dx * dx );
        const pistonY = crankWorldY - dyRod;

        vPistonPos.set( 0, pistonY, 0.5 ); // 活塞销位置

            // 4. 应用位置
        this.mainPiston.position.set( 0, pistonY, 0 );
            
            // 5. 连杆定位与旋转
            // 5.1 位置：连杆顶部直接设为曲柄销位置
        this.rod.position.copy( vCrankPos );
            // 5.2 旋转：连杆"看"向活塞销
        this.rod.lookAt( vPistonPos );
            // lookAt 默认是Z轴朝向目标，我们需要调整一下朝向逻辑
            // BoxGeometry 默认长在Y轴。
            // 简单修正：计算 2D 角度更直接
        const rodAngle = Math.atan2( pistonY - crankWorldY, 0 - crankWorldX ) + Math.PI/2;
        this.rod.rotation.set( 0, 0, rodAngle );

            // --- B. 热力学状态机 ---
            
            // 计算气体区域高度 (活塞底面 到 气缸底座)
            // 活塞中心在 pistonY, 底面在 pistonY - pistonHeight/2
            // 气缸底座在 Y=0.2 (cap thickness)
        const gasTop = pistonY - this.pistonHeight/2;
        const gasBase = 0.2;
        let gasH = gasTop - gasBase;
        if ( gasH < 0 ) gasH = 0.01;

        this.midChamber.gas.scale.y = gasH;
            
            // 循环逻辑 (0度=TDC, 180度=BDC)
        let progress = 0;
        const isoBase = 3; 

            // 底部 1/4 空间检查:
            // 最低点(BDC)时，pistonY = this.flywheelY - this.crankRadius - this.rodLength = 14 - 2.5 - 9 = 2.5
            // 活塞底面 = 2.5 - 0.5 = 2.0. 
            // 气缸总高8，2.0 确实是 1/4 左右。

        const TextDom = this.Div.querySelector( '.canvtext' );
        TextDom.style.display = 'block';
        
        const phasesZh = [
            '等温压缩：气缸与冷腔连通',
            '绝热压缩：气缸与冷腔隔断',
            '等温膨胀：气缸与热腔连通',
            '绝热膨胀：气缸与热腔隔断'
        ];
        const phasesEn = [
            'Isothermal Compression: Cylinder connected to cold chamber',
            'Adiabatic Compression: Cylinder isolated from cold chamber',
            'Isothermal Expansion: Cylinder connected to hot chamber',
            'Adiabatic Expansion: Cylinder isolated from hot chamber'
        ];
        const phases = currentLang === 'zh' ? phasesZh : phasesEn;

        if( this.Angle < Math.PI / 2 )
        {
            TextDom.innerText = phases[0];
            progress = this.Angle / ( Math.PI/2 );
            this.valves.left.scale.set( 0, 0, 0 );
            this.gasMidMat.color.copy( this.colorHot );
        }
        else if( this.Angle < Math.PI )
        {
            TextDom.innerText = phases[1];
            progress = ( this.Angle - Math.PI / 2 ) / ( Math.PI / 2 );
            this.valves.left.scale.set( 0.4, 1.2, 1.2 );
            this.gasMidMat.color.lerpColors( this.colorHot, this.colorCold, progress );
        }
        else if( this.Angle < Math.PI * 1.5 )
        {
            TextDom.innerText = phases[2];
            progress = ( this.Angle - Math.PI ) / ( Math.PI / 2 );
            this.valves.right.scale.set( 0, 0, 0 );
            this.gasMidMat.color.copy( this.colorCold );
        }
        else
        {
            TextDom.innerText = phases[3];
            progress = ( this.Angle - Math.PI * 1.5 ) / ( Math.PI / 2 );
            this.valves.right.scale.set( 0.4, 1.2, 1.2 );
            this.gasMidMat.color.lerpColors( this.colorCold, this.colorHot, progress );
        }

        this.isoPistons.left.position.x = -isoBase + Math.cos( this.Angle );
        this.isoPistons.right.position.x = isoBase - Math.cos( this.Angle );
        
        this.renderer.render( this.scene, this.camera );
    }
}

const engines = {
    'rotate': new RotEngine( 'rotate', 1 ),
    'rotate2': new RotEngine( 'rotate2', 0 ),
    'reciprocate': new ReciEngine( 'reciprocate', 1 ),
    'ring': new RingEngine( 'ring', 1 ),
    'ring2': new EmptyEngine( 'ring2', 1 ),
    'switch': new ThermalSwitch( 'switch', 1 )
};

document.addEventListener('DOMContentLoaded', () => {
    const tabsNav = document.querySelector('.tabs-nav');
    const tabButtons = document.querySelectorAll('.tab-button');
    const tabPanes = document.querySelectorAll('.tab-pane');
    const iframes = document.querySelectorAll('.tab-pane iframe');

    const switchTab = (targetId) => {
        // Deactivate all tabs and panes
        tabButtons.forEach(button => button.classList.remove('active'));
        tabPanes.forEach(pane => pane.classList.remove('active'));

        // Stop all canvas animations
        Object.values(engines).forEach(engine => {
            if (engine.Run) {
                engine.Stop();
            }
        });

        // Unload all iframes
        iframes.forEach(iframe => {
            if (iframe.src) {
                iframe.src = '';
            }
        });

        // Activate the target tab and pane
        const targetButton = document.querySelector(`.tab-button[data-target="${targetId}"]`);
        const targetPane = document.getElementById(targetId);

        if (targetButton && targetPane) {
            targetButton.classList.add('active');
            targetPane.classList.add('active');

            // Load iframe if it exists in the active pane
            const activeIframe = targetPane.querySelector('iframe');
            if (activeIframe && activeIframe.dataset.src) {
                activeIframe.src = activeIframe.dataset.src;
            }
        }
    };

    tabsNav.addEventListener('click', (event) => {
        if (event.target.classList.contains('tab-button')) {
            const targetId = event.target.dataset.target;
            switchTab(targetId);
        }
    });

    // Initialize the first tab
    const firstTab = document.querySelector('.tab-button.active');
    if (firstTab) {
        switchTab(firstTab.dataset.target);
    }
});

</script>
</body>
</html>
