<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>卡诺热机/热泵</title>
<style>
    .canvtext { position:absolute; display:none; color:white; background-color:rgba(0,0,0,0.5); padding:5px; z-index:10 }
    .container { position:relative; vertical-align:top; display:inline-block; margin-right:80px; border:solid 1px; padding:10px }
</style>
</head>
<body>
<h1>卡诺热机/热泵</h1>
<p>本人发明了世界首创的卡诺热机/热泵。其工质气体的工作循环为真正的卡诺循环：1、等温膨胀，2、绝热膨胀，3、等温压缩，4、绝热压缩。</p>
<p>具有热功转换效率高、结构简单、易于维护、灵活自启动、适用于多种热源/冷源、无须曲轴即可输出旋转动力等优势。工质气体与外界不以活塞分隔，能有效防止泄漏。能在所有场合替换斯特林热机/热泵，并可在发电、工业动力与大型交通工具上替代其它热机。</p>
<p>正在申请专利。需要在技术或专利方面合作者请联系：saintthor@gmail.com 。</p>
<h2>原理</h2>
<div id="rotate" class="container">
    <div class="canvtext" style="top:10px; left:10px;"></div>
    <div class="canvtext" style="top:10px; left:280px;"></div>
    <div class="canvtext" style="top:370px; left:120px;"></div>
    <canvas width="400" height="400"></canvas>
    <div>
        <span>旋转式热机</span>&emsp;
        <button>Start</button>
    </div>
    <div style="width:400px;">
        <p>气缸在立面上旋转。活塞的重力压缩下方的气体使之升温，在最低点温度最高时进入温度与高温相等的热源，开始<b>等温膨胀</b>过程。</p>
        <p>离开热源后是<b>绝热膨胀</b>过程。降温至最高点，进入温度与低温相等的冷源，开始<b>等温压缩</b>过程。</p>
        <p>离开冷源后是<b>绝热压缩</b>过程。</p>
        <p>调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合卡诺循环的定义。</p>
        <p>活塞在左侧时对气缸的旋转做功，在右侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此在连续旋转中活塞对气缸做的净功是逆时针方向的，可以维持气缸旋转并对外做功。</p>
    </div>
</div>

<div id="rotate2" class="container">
    <div class="canvtext" style="top:10px; left:10px;"></div>
    <div class="canvtext" style="top:10px; left:280px;"></div>
    <div class="canvtext" style="top:370px; left:120px;"></div>
    <canvas width="400" height="400"></canvas>
    <div>
        <span>旋转式热泵</span>&emsp;
        <button>Start</button>
    </div>
    <div style="width:400px;">
        <p>气缸在立面上受外力驱动旋转。活塞的重力压缩下方的气体，转到最下方时脱离热源，开始<b>绝热膨胀</b>过程，逐渐降温。</p>
        <p>在左侧进入冷源，冷源的温度与降温后的气体相同，进入<b>等温膨胀</b>过程，从冷源吸收热量。在最高点离开冷源，开始<b>绝热压缩</b>过程，逐渐升温。</p>
        <p>在右侧进入热源，热源的温度与升温后的气体相同，开始<b>等温压缩</b>过程，向热源释放热量。</p>
        <p>调节冷热源的温度和长度令其分别与两个绝热过程末的温度相等。每一端的工质气体旋转一周经历上述四个可逆过程，符合逆卡诺循环的定义。</p>
        <p>活塞在右侧时对气缸的旋转做功，在左侧时气缸对活塞做功。由于右侧温度高，活塞运动轨迹在左侧较多，且在左侧时更远离原点，因此需要依赖外界做功才能维持运转。</p>
    </div>
</div>

<hr>
<div id="reciprocate" class="container">
    <div class="canvtext" style="top:10px; left:10px;">left</div>
    <div class="canvtext" style="top:10px; left:480px;">right</div>
    <canvas width="600" height="280"></canvas>
    <div>
        <span>往复式热机</span>&emsp;
        <button>Start</button>
    </div>
    <div>
        <p>往复式的气缸能在左右方向上运动。当其内的活塞往复运动时，气缸会向相反方向运动，二者的和动量为零，振幅与二者的质量成反比。</p>
        <p>在每一边的工质气体压缩至温度最高时加上与气体温度相等的热源，同时另一边膨胀到温度最低，加上与气体温度相等的冷源，则两边分别进入等温膨胀/压缩过程。</p>
        <p>撤除热/冷源后两边分别为绝热膨胀/压缩过程，至运动到另一方向的极限位置后再反向加冷/热源，两边分别进入等温压缩/膨胀过程。</p>
        <p>撤除冷/热源后两边分别为绝热压缩/膨胀过程。在每个周期之内每一边的工质气体都经历卡诺循环的四个过程。</p>
        <p>通过气缸的运动对外做功。</p>
    </div>
</div>

<hr>
<div id="ring" class="container">
    <div class="canvtext" style="top:10px; left:10px;"></div>
    <div class="canvtext" style="top:10px; left:280px;"></div>
    <canvas width="400" height="400"></canvas>
    <div>
        <span>环管动能式热机</span>&emsp;
        <button>Start</button>
    </div>
    <div style="width:400px;">
        <p>气缸为环形管，上有两个阀门，总是一开一闭。两根直管两端也各有一个阀门。所有阀门绿色为导通，红色为截止。直管上的阀门状态总是与较近的环管阀门相反。</p>
        <p>任一时刻，气缸通路总是由一根直管的红色阀门开始，经过三个绿色阀门，转一圈后，到达另一根直管的红色阀门，形状如同 C 字的两端各自向里回钩。</p>
        <p>环形管每旋转半圈，阀门切换一次，所有阀门一齐翻转。C 字形的开口在每次阀门切换时会由向左变为向右。</p>
        <p>环管下方有一段高密度的液柱。由于环管可旋转且较轻，无负载时液柱总是保持在正下方。液柱两侧气压不同时会驱动环形管转动。</p>
        <p>每次阀门切换之后，对下方的直管加热源，对上方的直管加冷源，则液柱右侧热直管一端的气体为等温膨胀，液柱左侧冷直管一端的气体为等温压缩。</p>
        <p>撤除热源与冷源后，环管因惯性继续旋转，液柱右侧的气体为绝热膨胀，液柱左侧的气体为绝热压缩。对惯性的利用方式与往复式热机相似。</p>
        <p>绿色的环管阀门离开液柱区域之后，阀门切换，原压缩端变成膨胀端，原膨胀端变成压缩端，开始下一个循环。</p>
        <p>通过气缸的旋转对外做功。</p>
        <p>这种热机能灵活适配可变的负载。负载越大，液柱的位置越向左偏。</p>
    </div>
</div>

<div id="ring2" class="container">
    <div class="canvtext" style="top:10px; left:10px;">left</div>
    <div class="canvtext" style="top:10px; left:480px;">right</div>
    <canvas width="400" height="400"></canvas>
    <div>
        <span>环管势能式热机</span>&emsp;
        <button>Start</button>
    </div>
    <div>
        <p>通过气缸的运动对外做功。</p>
    </div>
</div>
<hr>
<h2>实物模型</h2>
<div>这些模型都是用水作活塞，气密性高，阻力小。适用于低温差（5度左右）的场景。若要适配于高温差的工业场景，应增大转盘尺寸，及换用高密度液体，才能近似卡诺循环。</div>
<div>
    <h3>叉管旋转式卡诺热机</h3>
    <iframe src="https://embed.wave.video/tk7QOjRSttH0TcbS" height="420" width="560" frameborder="0" allow="autoplay; fullscreen" scrolling="no"></iframe>
</div>
<div>
    <h3>内环管旋转式卡诺热机</h3>
    <iframe src="https://embed.wave.video/Nn0ZnBfUu5zJMzl5" height="420" width="560" frameborder="0" allow="autoplay; fullscreen" scrolling="no"></iframe>
</div>
<div>
    <h3>低温差满管旋转式卡诺热机</h3>
    <iframe src="https://embed.wave.video/iJUNKnerXzky7jQw" height="420" width="560" frameborder="0" allow="autoplay; fullscreen" scrolling="no"></iframe>
</div>

<script type="text/javascript" src="https://counter4.optistats.ovh/private/counter.js?c=kwt9a3nklac41tmaqer9sbwzzeqshq7y&down=async" async></script>
<noscript><a href="https://www.freecounterstat.com" title="web counter"><img src="https://counter4.optistats.ovh/private/freecounterstat.php?c=kwt9a3nklac41tmaqer9sbwzzeqshq7y" border="0" title="web counter" alt="web counter"></a></noscript>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.134.0/examples/js/controls/OrbitControls.js"></script>

<script>

class Carnot
{
    constructor( Id, isEngine )
    {
        let self = this;
        this.Div = document.getElementById( Id );
        this.Canvas = this.Div.querySelector( 'canvas' );
        this.Div.querySelector( 'button' ).onclick = () => self.Run ? self.Stop() : self.Start();
        this.Div.onmouseover = () =>
        {
            if( this.Run < 0 )
            {
                this.Run = 0;
                this.Start();
                this.Stop();
            }
        }
        if( typeof( THREE ) === "undefined")
        {
            this.CTX = this.Canvas.getContext( '2d' );
        }
        this.Angle = 0;
        this.Interval = 40;
        this.Run = -1;
        this.IsEngine = isEngine;
    }

    async Start()
    {
        if( this.Run > 0 )
        {
            return;
        }

        this.Run = 1;
        this.Div.querySelector( 'button' ).innerText = 'Stop';

        let loop = async () =>
        {
            this.StaticProcess();
            if( this.Run === 0 )
            {
                console.log( "Stopping animation loop." );
                await new Promise( r => setTimeout( r, this.Interval * 4 ));
                //return;
            }
            else
            {
                this.Draw(); // Call the drawing/rendering method
                this.Angle += this.IsEngine ? 0.01 : -0.01;
                if( this.Angle < 0 )
                {
                    this.Angle += Math.PI * 2;
                }
            }
            await new Promise( r => setTimeout( r, this.Interval ));
            loop(); // Continue loop
        };

        loop();
    }

    StaticProcess()
    {
        if( this.Controls )
        {
            this.Controls.update();
            if( this.Run === 0 && this.renderer )
            {
                this.renderer.setClearColor( 0xebedaf );
                this.renderer.render( this.scene, this.camera );
            }
        }
    }

    Draw()
    {
        return typeof( THREE ) !== "undefined" ? this.Draw3d() : this.Draw2d();
    }

    Stop()
    {
        this.Run = 0;
        this.Div.querySelector( 'button' ).innerText = 'Start';
    }
}

class ReciEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );
        // --- 3D Specific Setup ---
        if( typeof( THREE ) !== "undefined" )
        {
            this.scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight; // Use window aspect ratio
            this.camera = new THREE.PerspectiveCamera( 75, 15 / 7, 0.1, 1000 );
            this.camera.position.set( 0, 0, 25 ); // Position camera
            this.camera.aspect = 15 / 7;
            this.camera.position.z = 50;
            this.camera.fov = 20;
            this.camera.updateProjectionMatrix();

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
            this.scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );
            directionalLight.position.set( 10, 15, 20 );
            this.scene.add( directionalLight );

            this.CYLINDER_LENGTH = 20; // 无量纲，只表示比例
            this.CYLINDER_RADIUS = 2;
            this.PISTON_HEIGHT = 2;

            this.SetupObjects(); // Creates meshes and defines constants
            const [width, height] = [this.Canvas.width, this.Canvas.height];
            console.log( width, height );
            this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
            this.renderer.setSize( width, height );

            if( typeof THREE.OrbitControls !== 'undefined' )
            {
                this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
            }
        }
        else
        {
            this.Center = [Math.floor( this.Canvas.width / 2 ), Math.floor( this.Canvas.height / 2 )];
            this.LinderLength = 300;
            this.LinderWidth = 40;
            this.Interval = 24;
            this.Angle = 0;
            this.Base = { x: 150, y: 120 };
        }
        this.Draw();
    }

    SetupObjects()
    {
        // Create rotating group
        this.CyldGroup = new THREE.Group();
        this.scene.add( this.CyldGroup );

        // Create cylinder
        const cylinderGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS, this.CYLINDER_RADIUS, this.CYLINDER_LENGTH, 32, 1, true );
        const cylinderMaterial = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, transparent: true, opacity: 0.6, side: THREE.DoubleSide
        } );
        const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
        this.CyldGroup.add( cylinder );

        // Create caps
        const capGeometry = new THREE.CircleGeometry( this.CYLINDER_RADIUS, 32 );
        const capMaterial = new THREE.MeshPhongMaterial( { color: 0x666666 } );
        const topCap = new THREE.Mesh( capGeometry, capMaterial );
        topCap.position.y = this.CYLINDER_LENGTH / 2;
        topCap.rotation.x = Math.PI / 2;
        this.CyldGroup.add( topCap );
        const bottomCap = new THREE.Mesh( capGeometry, capMaterial );
        bottomCap.position.y = -this.CYLINDER_LENGTH / 2;
        bottomCap.rotation.x = -Math.PI / 2;
        this.CyldGroup.add( bottomCap );

        // Create piston
        const pistonGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS - 0.1, this.CYLINDER_RADIUS - 0.1, this.PISTON_HEIGHT, 32 );
        const pistonMaterial = new THREE.MeshPhongMaterial( { color: 0x444444 } );
        this.piston = new THREE.Mesh( pistonGeometry, pistonMaterial ); // Store piston reference
        this.CyldGroup.add( this.piston );

        this.CyldGroup.rotation.z = Math.PI / 2;

        const HotGeometry = new THREE.PlaneGeometry( 3, 1 );
        const HotMaterial = new THREE.MeshBasicMaterial( { color: 0xff0000 } );
        const ColdMaterial = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
        this.HotSrc = new THREE.Mesh( HotGeometry, HotMaterial );
        this.ColdSrc = new THREE.Mesh( HotGeometry, ColdMaterial );
        this.HotSrc.position.y = this.ColdSrc.position.y = -3;
        //this.LeftSrc.visible = false;
        this.HotSrc.position.x = -9;
        this.ColdSrc.position.x = 9;
        //hotArc.position.z = -1; // Push back slightly
        this.scene.add( this.HotSrc );
        this.scene.add( this.ColdSrc );

        this.scene.add( new THREE.AxesHelper( 12 ));
    }

    Draw3d()
    {
         if( !this.renderer || !this.scene || !this.camera )
         {
             console.log( "Renderer, scene, or camera not ready for Draw.", this.renderer, this.scene, this.camera );
             return;
         }

        if ( !this.piston ) return; // Guard clause

        //const [Sin, Cos] = [Math.sin( this.Angle ), Math.cos( this.Angle )];
        const Offset = Math.sin( this.Angle );
        this.CyldGroup.position.x = Offset * this.CYLINDER_LENGTH / 8;
        this.piston.position.y = Offset * this.CYLINDER_LENGTH / 4;

        if( this.Run > 0 )
        {
            const TextDoms = Array.from( this.Div.querySelectorAll( '.canvtext' ));
            const Quadrant = Math.floor( this.Angle / Math.PI * 2 ) % 4;
            const Stages = [['绝热压缩', '绝热膨胀'], ['等温膨胀', '等温压缩'], ['绝热膨胀', '绝热压缩'], ['等温压缩', '等温膨胀']][Quadrant];

            this.HotSrc.position.x = [50, -6, 50, 6][Quadrant];
            this.ColdSrc.position.x = [50, 9, 50, -9][Quadrant];

            TextDoms[0].innerText = '左侧：' + Stages[0];
            TextDoms[1].innerText = '右侧：' + Stages[1];
            TextDoms.forEach( t => t.style.display = 'block' );
        }

        // Render the 3D scene
        //if( this.Controls )
        //{
            //this.Controls.update();
        //}
        this.renderer.setClearColor( 0xebedaf );
        this.renderer.render( this.scene, this.camera );
    }

    Draw2d()
    {
        this.CTX.clearRect( 0, 0, this.Canvas.width, this.Canvas.height );

        this.CTX.beginPath();       //中线
        this.CTX.moveTo( this.Center[0], 50 );
        this.CTX.lineTo( this.Center[0], 250 );
        this.CTX.lineWidth = 2;
        this.CTX.strokeStyle = 'lightgray';
        this.CTX.stroke();

        this.CTX.strokeStyle = 'black';    //气缸
        this.CTX.lineWidth = 2;
        this.CTX.fillStyle = 'white';
        const offset = Math.sin( this.Angle ) * 40;
        this.CTX.fillRect( this.Base.x + offset + 1, this.Base.y + 1, this.LinderLength - 2, this.LinderWidth - 2 );
        this.CTX.strokeRect( this.Base.x + offset, this.Base.y, this.LinderLength, this.LinderWidth );

        this.CTX.fillStyle = 'darkgray';
        this.CTX.fillRect( this.Canvas.width / 2 - 20 - offset * 0.8, this.Base.y, 40, this.LinderWidth );

        const Angle = this.Angle % ( Math.PI * 2 );
        let stage = '绝热';
        if( Angle < Math.PI && Angle > Math.PI * 0.5 )
        {
            stage = '等温';
            this.CTX.fillStyle = 'red';
            this.CTX.fillRect( 180, this.Base.y + 45, 50, 20 );
            this.CTX.fillStyle = 'blue';
            this.CTX.fillRect( 420, this.Base.y + 45, 50, 20 );
        }
        else if( Angle < Math.PI * 2 && Angle > Math.PI * 1.5 )
        {
            stage = '等温';
            this.CTX.fillStyle = 'red';
            this.CTX.fillRect( 370, this.Base.y + 45, 50, 20 );
            this.CTX.fillStyle = 'blue';
            this.CTX.fillRect( 130, this.Base.y + 45, 50, 20 );
        }

        const Status = Number( Angle < Math.PI * 1.5 && Angle > Math.PI * 0.5 );
        this.CTX.fillStyle = 'black';
        this.CTX.font = '16px Arial';
        this.CTX.fillText( stage + ['压缩','膨胀'][Status], 180, 80 );
        this.CTX.fillText( stage + ['膨胀','压缩'][Status], 360, 80 );
    }
}

class RotEngine extends Carnot
{
    constructor( Id, isEngine )
    {
        super( Id, isEngine );

        // --- 3D Specific Setup ---
        if( typeof( THREE ) !== "undefined" )
        {
            this.scene = new THREE.Scene();

            const aspect = window.innerWidth / window.innerHeight; // Use window aspect ratio
            this.camera = new THREE.PerspectiveCamera( 75, aspect, 0.1, 1000 );
            this.camera.position.set( 0, 0, 25 ); // Position camera
            this.camera.aspect = 1;
            this.camera.updateProjectionMatrix();

            const ambientLight = new THREE.AmbientLight( 0xffffff, 0.6 );
            this.scene.add( ambientLight );

            const directionalLight = new THREE.DirectionalLight( 0xffffff, 0.9 );
            directionalLight.position.set( 10, 15, 20 );
            this.scene.add( directionalLight );

            this.CYLINDER_LENGTH = 24; // 无量纲，只表示比例
            this.CYLINDER_RADIUS = 2;
            this.PISTON_HEIGHT = 2;

            this.SetupObjects(); // Creates meshes and defines constants
            const [width, height] = [this.Canvas.innerWidth, this.Canvas.innerHeight];
            this.renderer = new THREE.WebGLRenderer( { canvas: this.Canvas, antialias: true } );
            this.renderer.setSize( 400, 400 );

            if( typeof THREE.OrbitControls !== 'undefined' )
            {
                this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
            }
            this.DiffAngle = 0.01;
            this.OldPistonPos = 0;
        }
        else
        {
            this.Center = [Math.floor( this.Canvas.width / 2 ), Math.floor( this.Canvas.height / 2 )];
            this.LinderLength = 280;
            this.LinderWidth = 30;
            this.Radius = 150;
        }
        this.Draw();
    }

    SetupObjects()
    {
        // Create rotating group
        this.rotatingGroup = new THREE.Group();
        this.scene.add( this.rotatingGroup );

        // Create cylinder
        const cylinderGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS, this.CYLINDER_RADIUS, this.CYLINDER_LENGTH, 32, 1, true );
        const cylinderMaterial = new THREE.MeshPhongMaterial( {
            color: 0xaaaaaa, transparent: true, opacity: 0.6, side: THREE.DoubleSide
        } );
        const cylinder = new THREE.Mesh( cylinderGeometry, cylinderMaterial );
        this.rotatingGroup.add( cylinder );

        // Create caps
        const capGeometry = new THREE.CircleGeometry( this.CYLINDER_RADIUS, 32 );
        const capMaterial = new THREE.MeshPhongMaterial( { color: 0x666666 } );
        const topCap = new THREE.Mesh( capGeometry, capMaterial );
        topCap.position.y = this.CYLINDER_LENGTH / 2;
        topCap.rotation.x = Math.PI / 2;
        this.rotatingGroup.add( topCap );
        const bottomCap = new THREE.Mesh( capGeometry, capMaterial );
        bottomCap.position.y = -this.CYLINDER_LENGTH / 2;
        bottomCap.rotation.x = -Math.PI / 2;
        this.rotatingGroup.add( bottomCap );

        // Create piston
        const pistonGeometry = new THREE.CylinderGeometry( this.CYLINDER_RADIUS - 0.1, this.CYLINDER_RADIUS - 0.1, this.PISTON_HEIGHT, 32 );
        const pistonMaterial = new THREE.MeshPhongMaterial( { color: 0x444444 } );
        this.piston = new THREE.Mesh( pistonGeometry, pistonMaterial ); // Store piston reference
        this.rotatingGroup.add( this.piston );

        // Heat Source / Cold Source Indicators ( Arcs )
        const arcRadius = this.CYLINDER_LENGTH * 0.6; // Adjust radius as needed
        const hotArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, 3 * Math.PI / 2, 2 * Math.PI, false ).getPoints( 50 )
        );
        const hotArcMaterial = new THREE.LineBasicMaterial( { color: 0xff0000, linewidth: 3 } );
        const hotArc = new THREE.Line( hotArcGeometry, hotArcMaterial );
        hotArc.position.z = -1; // Push back slightly
        this.scene.add( hotArc );

        const coldArcGeometry = new THREE.BufferGeometry().setFromPoints(
         new THREE.ArcCurve( 0, 0, arcRadius, Math.PI / 2, Math.PI, false ).getPoints( 50 )
        );
        const coldArcMaterial = new THREE.LineBasicMaterial( { color: 0x0000ff, linewidth: 3 } );
        const coldArc = new THREE.Line( coldArcGeometry, coldArcMaterial );
        coldArc.position.z = -1; // Push back slightly
        this.scene.add( coldArc );

        this.scene.add( new THREE.AxesHelper( 12 ));
    }

    Draw3d()
    {
         if( !this.renderer || !this.scene || !this.camera )
         {
             console.log( "Renderer, scene, or camera not ready for Draw.", this.renderer, this.scene, this.camera );
             return;
         }

        // Update objects based on state ( this.Angle )
        if( this.rotatingGroup )
        {
            this.rotatingGroup.rotation.z = this.Angle;
        }

        if ( !this.piston ) return; // Guard clause

        const [Sin, Cos] = [Math.sin( this.Angle ), Math.cos( this.Angle )];
        const Offset = -Cos * ( Sin * Cos > 0 ? 1.2 : 0.8 ) + ( Sin > 0 ? 0.2 : -0.2 );
        this.piston.position.y = Offset * this.CYLINDER_LENGTH / 4;

        if( this.Run > 0 )
        {
            const TextDoms = Array.from( this.Div.querySelectorAll( '.canvtext' ));
            const stage = Sin * Cos > 0 ? '等温' : '绝热';

            TextDoms[0].innerText = '左侧：' + stage + ( this.IsEngine ? '压缩' : '膨胀' );
            TextDoms[1].innerText = '右侧：' + stage + ( this.IsEngine ? '膨胀' : '压缩' );

            if( Offset * Sin > 0 )
            {
                TextDoms[2].innerText = ['气缸对活塞做功', '活塞对气缸做功'][this.IsEngine];
                TextDoms[2].style.left = '80px';
                this.DiffAngle += 0.0001;
            }
            else
            {
                TextDoms[2].innerText = ['活塞对气缸做功', '气缸对活塞做功'][this.IsEngine];
                TextDoms[2].style.left = '210px';
                this.DiffAngle += -0.0001;
            }

            TextDoms.forEach( t => t.style.display = 'block' );

            if( this.IsEngine )
            {
                if( this.OldPistonPos < 0 && Offset * Sin > 0 )
                {
                    this.DiffAngle = 0;
                }
                this.Angle += this.DiffAngle;
                this.OldPistonPos = Offset * Sin;
            }
        }

        //if( this.Controls )
        //{
            //this.Controls.update();
        //}
        this.renderer.setClearColor( 0xebedaf );
        this.renderer.render( this.scene, this.camera );
    }

    Draw2d()
    {
        this.CTX.clearRect( 0, 0, this.Canvas.width, this.Canvas.height );

        this.CTX.beginPath();       //中线
        this.CTX.moveTo( this.Center[0], 50 );
        this.CTX.lineTo( this.Center[0], 350 );
        this.CTX.lineWidth = 2;
        this.CTX.strokeStyle = 'lightgray';
        this.CTX.stroke();

        this.CTX.lineWidth = 10;
        this.CTX.beginPath();       //热源
        this.CTX.arc( this.Center[0], this.Center[1], this.Radius, 0, Math.PI / 2, false );
        this.CTX.strokeStyle = 'red';
        this.CTX.stroke();

        this.CTX.beginPath();       //冷源
        this.CTX.arc( this.Center[0], this.Center[1], this.Radius, Math.PI, -Math.PI / 2, false );
        this.CTX.strokeStyle = 'blue';
        this.CTX.stroke();

        this.CTX.save();    //绘制旋转的气缸
        this.CTX.translate( ...this.Center );
        this.CTX.rotate( -this.Angle ); //逆时针旋转
        this.CTX.strokeStyle = 'black';    //绘制无填充色的矩形，仅有黑色边框
        this.CTX.lineWidth = 2;
        this.CTX.strokeRect( -this.LinderWidth / 2, -this.LinderLength / 2, this.LinderWidth, this.LinderLength );

        let Offset, stage;    // 计算活塞位置
        const Angle = this.Angle % ( Math.PI * 2 );
        if( Angle % Math.PI <= Math.PI / 2 )
        {    // 从最下方 0 ~ pi/2
            Offset = Math.cos( Angle ) * this.LinderLength / 3 - 26 * [1, -1][Number( Angle >= Math.PI )];
            stage = '等温';
        }
        else
        {   // pi/2 ~ pi
            Offset = Math.cos( Angle ) * ( this.LinderLength - 156 ) / 3 - 26 * [1, -1][Number( Angle >= Math.PI )];
            stage = '绝热';
        }
        this.CTX.fillStyle = 'darkgray';
        this.CTX.fillRect( -this.LinderWidth/2, Offset - 10, this.LinderWidth, 20 );
        this.CTX.restore();

        // 标记卡诺循环阶段
        this.CTX.fillStyle = 'black';
        this.CTX.font = '16px Arial';
        const Index = Number( this.IsEngine );
        this.CTX.fillText( `${ stage }压缩`, [300, 20][Index], 40 );
        this.CTX.fillText( `${ stage }膨胀`, [20, 300][Index], 40 );
        this.CTX.fillText( [['气缸对活塞做功', '      活塞对气缸做功'], ['活塞对气缸做功', '      气缸对活塞做功']][Index][Number( Offset * ( Angle - Math.PI ) < 0 && Angle % Math.PI <= Math.PI / 2 )], 130, 380 );
    }
}

class RingEngine extends Carnot
{
    constructor(Id, isEngine)
    {
        super(Id, isEngine);

        // 3D环管式热机的参数
        this.mainRadius = 8;
        this.pipeRadius = 0.8;
        this.connectionAngleOffsetDeg = 30;
        this.mainValveSize = 1.2;
        this.smallValveSize = 0.8;
        this.smallValveOffsetRatio = 0.02;
        this.rotationSpeed = 1.0;
        this.DiffAngle = 0;
        this.liquidLengthRad = Math.PI; // 180度液体区域
        this.activeZoneStartRad = Math.PI; // 从π开始
        this.activeZoneEndRad = 2 * Math.PI; // 到2π结束

        // 阀门角度位置
        this.mainValveAngles = [0, Math.PI]; // 主阀门在0度和180度

        // 状态变量
        this.currentMainValve1State = true;
        this.curPipeState = false;

        // 存储网格对象
        this.mainValveMeshes = [];
        this.smallValveMeshes = [];
        this.pipes = [];

        // --- 3D 设置 ---
        if (typeof(THREE) !== "undefined")
        {
            this.setupScene();
            this.setupObjects();
            this.scene.add( new THREE.AxesHelper( 12 ));
        }
        else
        {
            console.log('RingEngine 仅支持 3D 模式');
        }

        if( typeof THREE.OrbitControls !== 'undefined' )
        {
            this.Controls = new THREE.OrbitControls( this.camera, this.renderer.domElement );
        }

        this.Draw();
    }

    setupScene()
    {
        this.scene = new THREE.Scene();
        this.scene.background = new THREE.Color(0xffffdd);

        this.camera = new THREE.PerspectiveCamera(75, 1, 0.1, 1000);
        this.camera.position.set( this.mainRadius * -0.1, this.mainRadius * 0.2, this.mainRadius * 2.5 );
        //this.camera.lookAt(1, 2, 3);

        this.renderer = new THREE.WebGLRenderer({canvas: this.Canvas, antialias: true});
        this.renderer.setSize(this.Canvas.width, this.Canvas.height);

        // 材质
        this.valveClosedMaterial = new THREE.MeshStandardMaterial({
            color: 0xcc4444, metalness: 0.6, roughness: 0.4
        });
        this.valveOpenMaterial = new THREE.MeshStandardMaterial({
            color: 0x44cc44, metalness: 0.6, roughness: 0.4
        });
        this.ringMaterial = new THREE.MeshStandardMaterial({
            color: 0xaaaaaa, metalness: 0.5, roughness: 0.5,
            transparent: true, opacity: 0.5, side: THREE.DoubleSide
        });
        this.pipeMaterial = new THREE.MeshStandardMaterial({
            color: 0x666666, metalness: 0.5, roughness: 0.5
        });
        this.liquidMaterial = new THREE.MeshStandardMaterial({
            color: 0x1bc4c8, metalness: 0.1, roughness: 0.4, side: THREE.DoubleSide
        });
        this.hotMaterial = new THREE.MeshStandardMaterial({
            color: 0xff4444, metalness: 0.3, roughness: 0.3
        });
        this.coldMaterial = new THREE.MeshStandardMaterial({
            color: 0x4444ff, metalness: 0.3, roughness: 0.3
        });

        // 灯光
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
        this.scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.9);
        directionalLight.position.set(5, 10, 7);
        this.scene.add(directionalLight);

        this.clock = new THREE.Clock();
    }

    setupObjects()
    {
        // 创建旋转组
        this.rotatingGroup = new THREE.Group();
        this.scene.add(this.rotatingGroup);

        // 1. 主环管
        const ringGeometry = new THREE.TorusGeometry(this.mainRadius, this.pipeRadius, 32, 100);
        const ringMesh = new THREE.Mesh(ringGeometry, this.ringMaterial);
        ringMesh.rotation.x = Math.PI / 2;
        this.rotatingGroup.add(ringMesh);

        // 2. 主阀门
        const initialValve1InZone = this.isAngleInActiveZone(this.mainValveAngles[0]);
        const initialValve2InZone = this.isAngleInActiveZone(this.mainValveAngles[1]);
        this.currentMainValve1State = initialValve1InZone || !initialValve2InZone;

        const mainValvePos1 = new THREE.Vector3(this.mainRadius, 0, 0);
        const mainValve1 = this.createValve(
            mainValvePos1,
            this.mainValveSize,
            this.mainValveSize * 0.6,
            !this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial,
            true
        );
        mainValve1.rotation.z += Math.PI / 2;
        this.rotatingGroup.add(mainValve1);
        this.mainValveMeshes.push(mainValve1);

        const mainValvePos2 = new THREE.Vector3(-this.mainRadius, 0, 0);
        const mainValve2 = this.createValve(
            mainValvePos2,
            this.mainValveSize,
            this.mainValveSize * 0.6,
            this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial,
            true
        );
        mainValve2.rotation.z += Math.PI / 2;
        this.rotatingGroup.add(mainValve2);
        this.mainValveMeshes.push(mainValve2);

        // 3. 连接点和直管
        const offsetAngleRad = THREE.MathUtils.degToRad(this.connectionAngleOffsetDeg) * 0.37;
        const angleP1 = offsetAngleRad;
        const angleP2 = -offsetAngleRad;
        const angleP3 = Math.PI - offsetAngleRad;
        const angleP4 = Math.PI + offsetAngleRad;

        const P1 = new THREE.Vector3(this.mainRadius * Math.cos(angleP1) * 0.9, 0, -this.mainRadius * Math.sin(angleP1));
        const P2 = new THREE.Vector3(this.mainRadius * Math.cos(angleP2) * 0.9, 0, -this.mainRadius * Math.sin(angleP2));
        const P3 = new THREE.Vector3(this.mainRadius * Math.cos(angleP3) * 0.9, 0, -this.mainRadius * Math.sin(angleP3));
        const P4 = new THREE.Vector3(this.mainRadius * Math.cos(angleP4) * 0.9, 0, -this.mainRadius * Math.sin(angleP4));

        // 4. 直管
        const straightPipe1 = this.createPipe(P2, P4, this.pipeRadius * 0.9, this.pipeMaterial);
        this.rotatingGroup.add(straightPipe1);
        this.pipes.push(straightPipe1);

        const straightPipe2 = this.createPipe(P1, P3, this.pipeRadius * 0.9, this.pipeMaterial);
        this.rotatingGroup.add(straightPipe2);
        this.pipes.push(straightPipe2);

        // 5. 小阀门
        const dirPipe1 = new THREE.Vector3().subVectors(P4, P2).normalize();
        const dirPipe2 = new THREE.Vector3().subVectors(P3, P1).normalize();
        const pipe1Length = P2.distanceTo(P4) * 0.3;
        const pipe2Length = P1.distanceTo(P3) * 0.3;

        const svPos1 = new THREE.Vector3().addVectors(P2, dirPipe1.clone().multiplyScalar(pipe1Length * this.smallValveOffsetRatio));
        const svPos2 = new THREE.Vector3().addVectors(P4, dirPipe1.clone().multiplyScalar(-pipe1Length * this.smallValveOffsetRatio));
        const svPos3 = new THREE.Vector3().addVectors(P1, dirPipe2.clone().multiplyScalar(pipe2Length * this.smallValveOffsetRatio));
        const svPos4 = new THREE.Vector3().addVectors(P3, dirPipe2.clone().multiplyScalar(-pipe2Length * this.smallValveOffsetRatio));

        const sv1_isOpen = this.currentMainValve1State;
        const sv2_isOpen = !this.currentMainValve1State;
        const sv3_isOpen = this.currentMainValve1State;
        const sv4_isOpen = !this.currentMainValve1State;

        const smallValve1 = this.createValve(svPos1, this.smallValveSize, this.smallValveSize * 0.6,
            sv1_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe1);
        this.rotatingGroup.add(smallValve1);
        this.smallValveMeshes.push(smallValve1);

        const smallValve2 = this.createValve(svPos2, this.smallValveSize, this.smallValveSize * 0.6,
            sv2_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe1);
        this.rotatingGroup.add(smallValve2);
        this.smallValveMeshes.push(smallValve2);

        const smallValve3 = this.createValve(svPos3, this.smallValveSize, this.smallValveSize * 0.6,
            sv3_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe2);
        this.rotatingGroup.add(smallValve3);
        this.smallValveMeshes.push(smallValve3);

        const smallValve4 = this.createValve(svPos4, this.smallValveSize, this.smallValveSize * 0.6,
            sv4_isOpen ? this.valveOpenMaterial : this.valveClosedMaterial, false, dirPipe2);
        this.rotatingGroup.add(smallValve4);
        this.smallValveMeshes.push(smallValve4);

        smallValve1.rotation.z += Math.PI / 2;
        smallValve2.rotation.z += Math.PI / 2;
        smallValve3.rotation.z += Math.PI / 2;
        smallValve4.rotation.z += Math.PI / 2;

        this.rotatingGroup.rotation.x = Math.PI / 2;

        // 6. 液体段
        try {
            const liquidArcGeometry = new THREE.TorusGeometry(
                this.mainRadius,
                this.pipeRadius,
                16, 50,
                this.liquidLengthRad * 0.83
            );
            this.liquidMesh = new THREE.Mesh(liquidArcGeometry, this.liquidMaterial);
            this.liquidMesh.rotation.x = Math.PI;
            this.liquidMesh.rotation.z = Math.PI / 12;;
            this.scene.add(this.liquidMesh);
        } catch(e) {
            console.error("创建液体几何体时出错:", e);
        }
    }

    createValve(position, radius, height, material, isMainValve = false, pipeDirection = null)
    {
        if (radius <= 0 || height <= 0) {
            console.error("阀门尺寸无效:", radius, height);
            return new THREE.Object3D();
        }

        try {
            const geometry = new THREE.CylinderGeometry(radius, radius, height, 20);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(position);

            if (isMainValve) {
                mesh.lookAt(0, 0, 0);
                mesh.rotateX(Math.PI / 2);
            } else if (pipeDirection && pipeDirection.lengthSq() > 0.0001) {
                const lookAtPos = new THREE.Vector3().addVectors(position, pipeDirection);
                if (lookAtPos.distanceTo(position) < 0.0001) {
                    lookAtPos.add(new THREE.Vector3(0, 1, 0));
                }
                const orientation = new THREE.Matrix4();
                const up = Math.abs(pipeDirection.normalize().y) > 0.99 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
                orientation.lookAt(position, lookAtPos, up);
                mesh.quaternion.setFromRotationMatrix(orientation);
                mesh.rotateY(Math.PI / 2);
            }

            return mesh;
        } catch(e) {
            console.error("创建阀门实例时出错:", e);
            return new THREE.Object3D();
        }
    }

    createPipe(point1, point2, radius, material)
    {
        const direction = new THREE.Vector3().subVectors(point2, point1);
        const length = direction.length();

        if (length < 0.0001) {
            console.warn("管道长度接近零");
            return new THREE.Object3D();
        }
        if (radius <= 0) {
            console.error("管道半径无效:", radius);
            return new THREE.Object3D();
        }

        try {
            const geometry = new THREE.CylinderGeometry(radius, radius, length, 16);
            const mesh = new THREE.Mesh(geometry, material);
            mesh.position.copy(point1).add(direction.multiplyScalar(0.5));

            const orientation = new THREE.Matrix4();
            const offsetRotation = new THREE.Matrix4();
            const up = Math.abs(direction.normalize().y) > 0.99 ? new THREE.Vector3(1, 0, 0) : new THREE.Vector3(0, 1, 0);
            orientation.lookAt(point1, point2, up);
            offsetRotation.makeRotationX(Math.PI / 2);
            orientation.multiply(offsetRotation);
            mesh.quaternion.setFromRotationMatrix(orientation);

            return mesh;
        } catch(e) {
            console.error("创建管道实例时出错:", e);
            return new THREE.Object3D();
        }
    }

    normalizeAngle(angle)
    {
        return ((angle % (2 * Math.PI)) + 2 * Math.PI) % (2 * Math.PI);
    }

    isAngleInRange(angle, start, end)
    {
        angle = this.normalizeAngle(angle);
        start = this.normalizeAngle(start);
        end = this.normalizeAngle(end);

        if (start <= end) {
            return angle >= start && angle <= end;
        } else {
            return angle >= start || angle <= end;
        }
    }

    isAngleInActiveZone(angle)
    {
        return this.isAngleInRange(angle, this.activeZoneStartRad, this.activeZoneEndRad);
    }

    inHeatingZone(angle)
    {
        return this.isAngleInRange(angle, this.activeZoneStartRad, this.activeZoneEndRad - 1);
    }

    Draw3d()
    {
        if( !this.renderer || !this.scene || !this.camera )
        {
            console.log("渲染器、场景或相机未准备好:", this.renderer, this.scene, this.camera);
            return;
        }

        const delta = this.clock.getDelta();

        // 1. 旋转组
        this.rotatingGroup.rotation.y = this.Angle;
        const currentGroupRotation = this.normalizeAngle(this.rotatingGroup.rotation.y);

        // 2. 确定期望状态
        const worldAngleValve0 = this.normalizeAngle(this.mainValveAngles[0] - currentGroupRotation);
        const worldAngleValve1 = this.normalizeAngle(this.mainValveAngles[1] - currentGroupRotation);
        const valve0InZone = this.isAngleInActiveZone(worldAngleValve0);
        const valve1InZone = this.isAngleInActiveZone(worldAngleValve1);
        const heat = this.Angle % Math.PI < 2;

        let desiredMainValve1State = this.currentMainValve1State;
        if (valve0InZone && !valve1InZone) {
            desiredMainValve1State = true;
        } else if (!valve0InZone && valve1InZone) {
            desiredMainValve1State = false;
        }

        let desiredPipeState = heat;
        if (desiredPipeState !== this.curPipeState) {
            this.curPipeState = desiredPipeState;
            this.pipes[0].material = this.curPipeState ?
                (desiredMainValve1State ? this.hotMaterial : this.coldMaterial) : this.pipeMaterial;
            this.pipes[1].material = this.curPipeState ?
                (!desiredMainValve1State ? this.hotMaterial : this.coldMaterial) : this.pipeMaterial;
        }

        // 3. 更新材质（如果状态改变）
        if (desiredMainValve1State !== this.currentMainValve1State) {
            this.currentMainValve1State = desiredMainValve1State;

            if (this.mainValveMeshes.length === 2) {
                this.mainValveMeshes[0].material = !this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
                this.mainValveMeshes[1].material = this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
            }
            if (this.smallValveMeshes.length === 4) {
                const sv1_sv3_material = this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
                this.smallValveMeshes[0].material = sv1_sv3_material;
                this.smallValveMeshes[2].material = sv1_sv3_material;
                const sv2_sv4_material = !this.currentMainValve1State ? this.valveOpenMaterial : this.valveClosedMaterial;
                this.smallValveMeshes[1].material = sv2_sv4_material;
                this.smallValveMeshes[3].material = sv2_sv4_material;
            }
            this.DiffAngle = 0;
        }

        this.DiffAngle += heat ? 0.0002 : -0.0003;
        this.Angle += this.DiffAngle;

        // 4. 更新文本显示

        if( this.Run > 0 )
        {
            const textDoms = Array.from(this.Div.querySelectorAll('.canvtext'));
            const HeatStr = heat ? '等温' : '绝热';
            if (textDoms.length >= 2) {
                textDoms[0].innerText = '左侧：' + HeatStr + '压缩';
                textDoms[1].innerText = '右侧：' + HeatStr + '膨胀';
                textDoms.forEach(t => t.style.display = 'block');
            }
        }

        // 5. 渲染
        this.renderer.render(this.scene, this.camera);
    }
}

new RotEngine( 'rotate', 1 );
new RotEngine( 'rotate2', 0 );
new ReciEngine( 'reciprocate', 1 );
new RingEngine( 'ring', 1 );
</script>
</body>
</html>
